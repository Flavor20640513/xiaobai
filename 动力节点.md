---
2024/3/9-2024/8/15 动力节点(北京校区)培训学习
---



[^关闭防火墙]: ftp://192.168.137.102->course

[TOC]



# JAVASE

## Java基础知识

[^面对对象的高级语言]: 

-------------------------------------------------**一.基础常识**-------------------------------------------------

1. jdk(开发者工具包)-->jre(java运行环境)-->jvm(java虚拟机)    jvm不能单独安装

2. sdk{   java sdk(jdk)   android sdk}

3. jre 和 sever jre的区别  (Server JRE更适合处理多用户并发请求和高负荷工作负载JRE更多地被用于客户端环境，而Server JRE则专门为服务器环境优化，适合在后台运行Java应用程序，特别是在需要处理大量并发请求和企业级应用中)

4. JAVASE基础个人    JAVAEE服务器端   JAVAME嵌入式

5. javap 反编译class文件

6. ----public class 和class   --->public修饰的类文件名和类名必须相同
7. finnal  定义常量
8. Math.rodom()*(max-min)+min;



-------------------------------------------------**二.基本数据类型**-------------------------------------------------

![image-20240311193752829](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240311193752829.png)

```
数据类型的作用:决定数据的存储方式,决定数据的取值范围,决定数据允许的操作
基本数据类型:  整数  小数  布尔 字符
引用数据类型:  类 接口 数组 注解 枚举 record
```

![image-20240311194032137](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240311194032137.png)



![image-20240311194131297](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240311194131297.png)

当byte、short、char类型进行运算时，则先转为int类型，然后再进行计算

取值范围小的数据类型是可以直接给取值范围大的数据类型赋值的，构成自动类型转换，也叫做隐式类型转换

取值范围大的数据类型是不可以直接给取值范围小的数据类型赋值的，则必须进行强制类型转换，也叫做显式类型转换，但是可能会存在精度有丢失

char的范围:  0-65535  

虽然字符类型可以存储整数值，但在进行算术运算时，为了确保数据的正确性和避免潜在的错误，通常需要显式地进行强制类型转换   如  char ch=(char)('a'+10);

97 65 48 32

面试题:int num = 5; num = num++;请问代码执行后num的值为多少？ num为5

-------------------------------------------------**三.运算符优先级**-------------------------------------------------

![image-20240314194620092](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240314194620092.png)

![image-20240316205057674](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240316205057674.png)

instanceof 运算符:该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

----------------------------------------------------**四.枚举**-----------------------------------------------------

```java
package ITjava.enumclass;

public class Hw01 {
    public static void main(String[] args) {
        A fruit=A.strawberry;

    }
}
enum A {
    banana,
    apple,
    grape,
    watermelon,
    strawberry;
}
```

----------------------------------------------------**五.方法(函数)**--------------------------------------------------

![image-20240318200623517](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240318200623517.png)

![image-20240318200748857](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240318200748857.png)

成员变量与局部变量的区别

1. 声明位置不同(方法中,类中)
2. 作用范围不同(方法中,类中)
3. 内存位置不同(栈的方法内存中,堆对象内存中)
4. 生命周期不同(随方法的执行而消失,随对象的消失而灭亡-->JVM垃圾自动回收)
5. 初始值不同(方法中无默认值要赋值,成员变量有初始值)
6. 可用修饰符不同(局部变量只能用final,而成员变量可以用private  public 等等)

-------------------------------------------------**六.参数的传递**-------------------------------------------------

```java
//基本数据类型的传递
public static void main(String[] args) {
        int x=10,y=20;
        System.out.println("x= "+x+",y= "+y);
        change(x,y);
        System.out.println("x= "+x+",y= "+y);
    }
    private static void change(int x, int y) {
        x+=10;
        y+=20;
        System.out.println("x的值: "+x+",y的值: "+y);
    }
//引用数据类型的传递-->类
//堆中只有一个对象实例 在方法中传的是地址 所以共同使用一个对象
public class Hw03 {
    public static void main(String[] args) {
        Student stu=new Student("张凤",15);
        stu.output();
        Hw03.change(stu);
        stu.output();
    }
    private static void change(Student stu) {
        stu.age=2222;
        stu.output();
    }
}
//引用数据类型的传递-->String
//堆中有一个常量池 当年字符串的值改变时,原先的并不会消失覆盖而是另起一个地址存值,此时会将地址返回给变量
public class Hw02 {
    public static void main(String[] args) {
        String s1="abc";
        System.out.println("s1 = "+s1);
        Hw02.change(s1);
        System.out.println("s1 = "+s1);
    }
    private static void change(String s2) {
        s2="ok";
        System.out.println("s2的值为: "+s2);
    }
}
```

-------------------------------------------------**七.IDEA的基本设置**-------------------------------------------------

```java
设置字节码: new Project
setting-->Editor-->File Encoding-->utf-8
打开文件位置:
open in->explorer
    
```

## 静态变量static

​          在类加载时就进存储区,不存储在类信息中,但可以被调用

​       静态变量的值可以被改变,一般不把此变量做构造函数  静态方法可以被重写,但一般不重写

1. static修饰变量
   类名.变量          对象名.变量         空对象名.变量

2. static修饰方法  (静态方法中只能调用静态方法或者静态变量 --->静态优先于其他对象变量或者成员变量)
       类名.方法           对象名.方法         空对象.方法

3. static静态代码块
        只执行一次,优先于对象的创建,只要有类就先将值赋值给静态变量

4. static静态内部类

    ​	静态修饰的内部类可直接访问
    ​    <----详细见上面 内部类---->

5. static也可以静态导入

    > ----import static  demo1.Mycalss.y----<

​          静态代码块与非静态代码块与构造函数的先后顺序

​                静态代码块>非静态代码块>构造函数

## finnal

```java
1. finnal修饰类       该类不能被继承
2. finnal修饰方法     该方法不能被重写
3. finnal修饰属性     属性值不再改变
4. finnal修饰引用数据类型如finnal Dog dog=new Dog()   
     注意: 此时改对象名的地址值始终指向定义的地址,但里面的值可以改变
5.局部变量只能用final来修饰
```

## instanceof

​       用来判断多态对象是否属于某个子类,如果属于则可以进行向下转型

​      语句:  person instanceof Student()  ----->true  false

## 三大特性

1. 封装

    [^特点]: 实例变量的值更加安全
     private定义的**实例对象**

    用set和get方法调用  

    set函数可以连缀

2. 继承

    [^特点]: 减少代码的冗余性(重复性)

     任何类都默认有一个object类,一个类有且只能继承一个父类(单根性、传递性)

    > ---this和super的区别---

     this会优先在本对象的实例中寻找实例变量,找不到才会去找父类的实例变量,而super会直接去父类找实例变量,速度比this来的

3. 多态

    [^特点]: 在继承的基础上继续优化代码，减少代码的冗余性

    格式:父类 对象名=new 子类();

    条件:子类必须继承父类,子类必须重写父类方法

    转化:

    ​          由子到父:自动转换类型,对象名只能访问父类的实例变量,只能访问子类重写的方法

    ​           由父到子: 先判断能不能转,Student stu=(Student) person;  对象名可以访问子类的属性和方

4. 抽象(abstract)

   ```java
   特殊的类,不能被实例化
   事务本质的抽象,解决对象到低是什么
   抽象 abstract class
   包含:  静态变量、实例变量、常量
         静态方法、抽象方法、普通方法、构造函数
   抽象类:
         类不能创建对象,只能通过子类来创建父类对象,多态的一种表现
   抽象方法:
         只能编写在抽象类中,抽象方法不能写任何语句,子类必须重写抽象类
   抽象是一种引用类型，在内存中存放的是内存地址
   可以使用private修饰
   ```
   
    ​  
   

| 访问权限          | 在当前类中 | 在当前包中 | 在不同包的子类中 | 在任意包的任意类中 |
| ----------------- | ---------- | ---------- | ---------------- | ------------------ |
| private私有的     | 可以使用   | 不可以使用 | 不可以使用       | 不可以使用         |
| 默认的            | 可以使用   | 可以使用   | 不可以使用       | 不可以使用         |
| protected受保护的 | 可以使用   | 可以使用   | 可以使用         | 不可以使用         |
| public公共的      | 可以使用   | 可以使用   | 可以使用         | 可以使用           |

![a](D:\course-dljd\02-JavaSE\a.png)

静态变量>对象变量>局部变量

## 接口

```java
A、面向抽象编程，面向接口编程，尽量使用多态机制
B、可以提高程序的扩展力，降低程序的耦合度
C、让程序变得具有很强的可接插特性
D、接口是一套规范，程序员应该面向接口去调用，而不需要关心接口底层的具体实现
功能的封装,一组操作的规范
多个抽象方法,就有多个功能的封装
    解决:对象具有什么功能,对象能干嘛
interface   implements      interface==abstract class
特点：
    类与类      单继承
    接口与接口  多继承
    类与接口    多实现
    1.不能创建对象 接口也是一种多态的表现与抽象类类似
    2.接口是一种引用类型，在内存中存放的是内存地址
包含：
    抽象方法      public abstract
    静态常量      public static final
    静态方法      public static
    默认方法      public default 
          （当一个类实现该接口时，它可以选择不重写这些default方法，而是直接使用接口提供的默认实现
 
```

## 内部类

```java
public class Hw02 {
    public static void main(String[] args) {
        //成员内部类
        C x=new C();
        C.D y=x.new D();
        System.out.println(x.c+"  "+y.d);
        //静态内部类
        A a=new A();
        A.B b=new A.B();
        System.out.println(a.x+"   "+b.y);
        //局部内部类
        X x=new X();
        x.output();
    }
}
//成员内部类
class C{
    int c=5;
    class D{
        int d=6;
    }
}
//静态内部类
class A{
    static Scanner input=new Scanner(System.in);
    int x=input.nextInt();
    static class B{
        int y=input.nextInt();
    }
}
//局部内部类
class X{
    int x=5;
    public void output(){
        class abstract Y{
            int a;
            void eat();
        }
       Y y=new Y();
        //y.a;
        y.eat();
    }
}
//匿名内部类    **********非常非常非常灰常重要***********
interface Animal{
    void eat();
}
class Test{
    public static void main(String []args){
        new Animal{
               @Override
            public void eat() {
                System.out.println("匿名内部类实现接口的方法");
            }
        }.eat();
    }
}
```

## Object类

```java
所有类的父类  默认继承Object   
 class A [extends Object]{}
1.toString()方法
    默认情况下输出对象名student,则内部自动调用toString()方法,返回对象的地址值
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
   重写toString()方法:
   1.ctrl+o 不推荐,重写自己写
   2.alt+insert  自动导入实例变量的输出值
2.equals()方法
     默认比较地址值,相当于==
     如果要比较对象内存地址的具体对象变量值,重写equals()方法;
重写前:  public boolean equals(Object obj) {
          return (this == obj);    }
    
重写后:  
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
            Dog dog = (Dog) o;
        return age == dog.age  && Double.compare(dog.weight, weight) == 0 && Objects.equals(name, dog.name) && Objects.equals(breed, dog.breed);     }

    字符串的比较:字符串内部自动将toString()方法重写了,而不是比较内存地址,而是字符串.
```

## JavaDoc

```java
//在网页上生成注释文档
/**
 * 学生类
 * @author 谢陈龙
 * @version 8.0.32
 */
public class Student {
    /**
     * 学生姓名
     */
    String name;
    /**
     * 学生住址
     */
    static String address;
    /**
     * 无参构造
     */
    public Student() {
    }

    /**
     * 带一个参数的构造
     *
     * @param name 赋值的name
     */
    public Student(String name) {
        this.name = name;
    }

    /**
     * 获取实例变量name的值
     *
     * @return 返回实例变量name的值
     */
    public String getName() {
        return name;
    }
    /**
     * 完成对name实例变量赋值
     *
     * @param name 赋值的name
     */
    public void setName(String name) {
        this.name = name;
    }
    /**
     * 计算俩个数的和
     *
     * @param a 第一个值
     * @param b 第二个值
     * @return 返回俩个数的和
     */
    public int sum(int a, int b) {
        return a + b;
    }
}

执行流程:
tools->generate JavaDoc->位置->public->-encoding utf-8 -charset utf-8
```

## 阶段小结

```
类的修饰符:
      public、[默认]、private、protected
      final(不能继承)、abstract(不能创建子类)、interface(不能创建子类)
方法的修饰符：
      public、[默认]、private、protected
      abstract(只能在抽象类中)、final(不能重写)、static(隐藏,不重写)
变量的修饰符:
       public、[默认]、private、protected
       final(不能改变值)、static(隐藏,不被构造函数)
       局部变量只能用final修饰
```

## 数组

```java
iter
1.格式: 1.数据类型 [] 数组名=new 数据类型[数据长度]
     2.数据类型 [] 数组名={   }   --->省略了new 数据类型[]{   }   仅用于数组初始化,不能给数组重新赋值

2.注意:不同类型的数组之间不能进行复制  
        如:int []ints=new int[10];     double[] v=ints;  错误的
4.数组扩容:
     int[] pv=new int[10];
     int[] bigger=new int[pv.length+pv.length/2+pv.length>>2];
     for(int i;i<pv.length;i++){
        bigger[i]=pv[i];
     }
    pv=bigger;

5.System.arraycopy(pv,0,bigger,0,ints.length) 
    将pv从0开始的数组赋给bigger从0开始的值,长度为ints.length
  netive 底层调用C/C++的本地方法(因此看不到arraycopy的实现过程)
6.数组删除,增加效率低   类似与数组扩容和缩小
     public static void main(String[] args) {
        int[] pv = new int[]{12, 45, 78, 36, 98, 12};  //删除第3个元素
        int[] smaller = new int[pv.length - 1];
        Scanner input = new Scanner(System.in);
        System.out.println("请输入删除第几个元素");
        int a = input.nextInt();
        System.arraycopy(pv, 0, smaller, 0, a - 1);
        System.arraycopy(pv, a, smaller, a - 1, pv.length - a);
        for (int x : smaller) {
            System.out.print(x + "  ");
        }
    }
7.数组的参数传递与返
    public static int[] getIntArray(int capacity){
        if(capacity<=0){
            return new int[0];
        }
        int[] array=new int[capacity];
        for (int i=0;i<capacity;i++){
            array[i]= (int) (Math.random()*3+2);
        }
        return array;
    }
8.偏移量:  ints+i*数据所占的偏移量     
    数组存储在连续的内存空间,每个元素占四个字节,共32个字节码,每个元素都有自己的内存地址值
9.数组与数组之间的赋值是将地址值给变量,当其中一个数组元素发生变化时,另一个也会发生变化 ******----******
10.可变长参数
     public static void main(String[] args) {
      sum();
            sum(1,2,3);
            sum(1,5,9,4,8,7,6,3);
            int[] ints=new int[]{4,8,6,9,7,52,31,26};
            sum(ints);
    }
    public static void sum(int ... date){  //可变长参数只能在参数最后一个位置存在
        for (int x : date) {
            System.out.print(x+" ");
        }
        System.out.println();
    }
```

```java
二维数组
   int[] ints = new int[10];
   int[] ints1 = new int[]{12, 14, 15, 36, 78, 25, 452, 13};
   int[] ints2 = {45, 23, 63, 48, 24, 37, 41, 29, 16};
格式:
   1.int[][] array1 = new int[3][8];
   2.int[][] array2 = new int[3][];
   3.int[][] array3 = new int[][]{ints1, ints2, ints};
   4.int[][] array4 = {ints2, ints, ints1};
   5.int[][] array5 = {new int[15], new int[]{12, 56, 78}, {4, 8, 6, 3, 9}};
输出:
private static void output(int[][] array1) {
        for (int[] p : array1) {
            for (int x : p) {
                System.out.print(x + " ");
            }
            System.out.println();
        }
    }
```

![image-20240330212320603](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240330212320603.png)

## String面试题

```java
public static void main(String[] args) {
        String s1 = "helloworld";
        String s2 = "helloworld";
        System.out.println( s1 == s2 );         //true

        String s3 = "hello";
        String s4 = s3 + "world";               //使用加号+对String字符串变量连接会创建新的字符串对象
        System.out.println( s1 == s4 );         //false   s4会在堆中创建String的对象,而不在常量池

        ///javac编译器会对字符串常量的连接进行优化. 即在把.java编译为.class字节码时优化
        String s5 = "hello" + "world";      //编译后,在.class字节码中这一行优化为 s5 = "helloworld"
        System.out.println( s1 == s5 );         //true

        final String s6 = "hello";          //final常量,
        String s7 = s6 + "world";           //javac会对final常量优化
        System.out.println( s1 == s7 );         //true

        //以下两行共创建了多少个String字符串对象?  3个,  会在常量池中创建"girlfriend", new出来两个
        String s8 = new String("girlfriend");
        String s9 = new String("girl" + "friend");

    }
----------------------------------------------------------------------------------------------------
        Integer i2 = 456;
        System.out.println( i2 == i1 );     //false,  i1,i2两个对象名保存了两个不同对象的引用

        Integer i3 = 45;        //程序执行时,  检测缓存, 没有value值为45的Integer对象, 在缓存中创建value值为45的Integer对象, 把这个对象的引用赋值给i3
        Integer i4 = 45;        //检测缓存, 存在value值为45的Integer对象, 直接把缓存中这个对象的引用赋值给i4, 即i3, i4两个对象名都保存了缓存中同一个Integer对象的引用
        System.out.println( i3 == i4 );     //true
       Integer i5 = Integer.valueOf(45);
        System.out.println( i3 == i5 );         //true
        Integer i6 = new Integer(45);
        System.out.println( i3 == i6 );         //false
        Short  s6 = 45;
        //System.out.println( s6 == i6 );         //语法错误  俩个不同数据类型的比较
        byte bb = 45;
        System.out.println( bb == i6 );         //true, 隐含自动拆箱
```

## 重要源码

```java
1.查看Arrays.toString( int [] )方法源码
public static String toString(int[] a) {
        if (a == null)
            return "null";
        int iMax = a.length - 1;
        if (iMax == -1)
            return "[]";

        StringBuilder b = new StringBuilder();
        b.append('[');
        for (int i = 0; ; i++) {
            b.append(a[i]);
            if (i == iMax)
                return b.append(']').toString();
            b.append(", ");
        }
    }
2.ArrayList<E> extends AbstractList<E> extends AbstractCollection<E> 的 toString()方法
     public String toString() {
        Iterator<E> it = iterator();
        if (! it.hasNext())
            return "[]";

        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
            E e = it.next();
            sb.append(e == this ? "(this Collection)" : e);
            if (! it.hasNext())
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }
3.ArrayList()源码
    public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    protected transient int modCount = 0;   //list添加或者删除元素的次数
    private static final int DEFAULT_CAPACITY = 10;       //数组默认长度
    private static final Object[] EMPTY_ELEMENTDATA = {};   
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    transient Object[] elementData;     //具体存储数据的数组 向ArrayList集合中添加的数据都保存到这个elementDate数组中
    private int size;                  //数组元素数量
        
        //在无参构造方法中,对elementData数组默认初始化长度为0的数组
        //会在第一次add()添加元素时,给此数组重新赋值一个默认长度为10的数组
    public ArrayList() {     
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; 
    }
        
        //避免频繁扩容,接收一个数组初始化长度
         //List list=new ArrayList(1000);
    public ArrayList(int initialCapacity) {  
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];  
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
        }
     }
        
        //在创建ArrayList集合中,把参数c的集合转换为数组赋值给elementData
        //List list2=new ArrayList(list)
     public ArrayList(Collection<? extends E> c) {  
        Object[] a = c.toArray();                   
        if ((size = a.length) != 0) {
            if (c.getClass() == ArrayList.class) {  //c是否是ArrayList的一个类实例(继承关系)
                elementData = a;
            } else {
                elementData = Arrays.copyOf(a, size, Object[].class);
            }
        } else {
            // replace with empty array.
            elementData = EMPTY_ELEMENTDATA;
        }
     }  
        
      public boolean add(E e) {
       ensureCapacityInternal(size+1);   //调用方法确定数组有足够的额外空间存储数据
       elementData[size++]=e;
        return true;
    }   
        
       //调用ArrayList()无参构造方法创建集合对象时,第一次add()添加时if成立
      public boolean ensureCapacityInternal(int minCapaticy) {
        if(elementData==DEFAULTCAPACITY_EMPTY_ELEMENTDATA){      
            minCapaticy=Math.max(DEFAULT_CAPACITY,minCapaticy)   
       }
        ensureExplicitCapacity(minCapacity);   
    }   
  //每次向集合中添加数据,或者从集合中remove()删除元素时,modCount()就会记录集合中修改次数的变量+1,在Iterator迭代时,会判断modCount变量的值
       public void ensureExplicitCapacity(int minCapacity){
           modCount++;     
           if(minCapacity - elementData.length > 0){
               grow(minCapacity);
           }
       }
     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
       private void grow(int minCapacity){
           int oldCapacity = elementData.length;
           int newCapacity = oldCapacity+(oldCapacity>>1);    //新数组是原来数组的1.5倍
           if(newCapacity - minCapacity < 0)
               newCapacity = minCapacity;
           if(newCapacity - MAX_ARRAY_SIZE > 0)
               newCapacity = hugeCapaticy(minCapacity);
           elementData = Array.copyOf(elementData , newCapacity);  //第一次添加时,给数组扩容为10 的数组
             
       }
     private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
        //判断是否包含元素
    public boolean contains(Object o) {
        return indexOf(o) >= 0;
    }
//*******************重要的源码*************************
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    } 
        //删除元素
      public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;    //0-size-1
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,numMoved);
        elementData[--size] = null; 
    }   
    }
4.LinkedList()源码
    
    
5.
```



## Java常用类

[注意:^]: 除了lang包不用导,其他包都要导

UTF-8, 这是一种Unicode编码, 在这种编码中,一个英文字符对应1byte字节的二进制,一个汉字对应3byte字节的二进制
UTF-16, 这是一种Unicode编码, 不管英文还是中文都对应 2  byte字节的二进制,  char类型数据采用UTF16编码
GBK/GB2312, 这是中文编码, 在这种编码中,一个英文字符对应1byte字节的二进制,一个汉字对应2 个byte字节的二进制, 区别在于GB2312包含的字符数量比GBK多
ASCII, 美国的标准信息交换码, 只有英文, 1个byte
ISO8859-1, 西欧编码, 也称为Latin编码, 兼容ASCII, 后面学习的Tomcat服务器默认编码

注意事项:

   1.String字符串由若干字符组成, 在JDK8之前底层定义private final char value[]字符数组来保存字符串的每个字符; 从JDK9开始,底层定义private final byte[]value字节数组来保存字符串的每个字符, 目的是为了节省存储空间,从JDK9开始,String底层在存储或者操作时,先判断字符编码,<u>String类底层使用private final  byte[]value字节数组来保存字符串的每个字符该数组是**private**私有的,我们没有权限修改value数组的元素String类也没有相应的方法修改value数组元素</u>

   3.如果方法返回类型是基本数据类型或String 则一般不改变原先的值    如果方法的返回类型返回类型是引用类类型,则一般自身也一起改变

  4.字符串的toString()调用自身的toString方法            equals()调用自身重写的equals方法,比较字符串具体的值     

​    数组的toString()调用Arrays的toString方法                 equals()调用Arrays类重写的equals()方法(数值,长度,类型的比较)                                                         sort()调用Arrays的sort()方法但排序依赖Comparable<Student>接口的compareTo

​    引用数据类型的toString() 继承Object的toSting方法要重写才能进行比较    equals()继承Object的equals方法要重写才能进行比较       sort()实现Comparable<Student>接口的compareTo(T o)方法

  

```java
lang包
    String类--->//不需要new 对象
     1.构造方法
           byte[] bytes = {65, 66, 67, 68, 33, -26, -68, -90, -27, -97, -110, -5};
           char[] chars = {'a', 'b', 'c', '男', 30000, 30088, 40000, '人'};
          第一种:
             String s="hello";
          第二种:
              String s2 = new String(bytes);         //把bytes数组中所有的字节以默认的UTF8编码解析为字符串(中文三字节)
              String s2 = new String(bytes, 0, 6);   //把bytes数组从0开始的6个字符连接为字符串(这里的6是个数)
          第三种:
             String s4 = new String(chars);           //把chars数组所有的字符连接为字符串
             String s5 = new String(chars, 0,5);      //把chars数组从0开始的5个字符连接为字符串(这里的5是个数)
     2.常用方法:
                 String s = "Hello动力节点";
          int length()                               //字符串中字符的数量
          char charAt(int index)                     //返回字符串中 index 位置的字符      
          int compareTo(String anotherString)        //比较两个字符串大小     int a="hello".compareTo(s)
          int compareToIgnoreCase(String str)        //忽略大小写后再比较字符串大小  //正数 负数 0
  /*说明:String类实现了Comparable接口, 重写compareTo方法, 在该方法中定义两个字符串比较大小的规则:逐个比较字符串的每个字符, 遇到第一个不一样的字符码值相减, 如果前面的字符都一样,再比较字符串的长度 */ 
          boolean contains(CharSequence s) //判断当前字符串是否包含s字符串   
  /*说明:参数CharSequence是一个接口,在调用方法时,实参传递 CharSequence 接口的实现类对象或者匿名内部类对象, CharSequence接口的实现类有: String,  StringBuilder, StringBuffer*/     
          boolean endsWith(String suffix)            //判断当前字符串是否以suffix结尾
          boolean startsWith(String prefix)          //判断当前字符串是否以 prefix 开头
          boolean equals(Object anObject)            //判断两个字符串是否一样
          boolean equalsIgnoreCase(String anotherString)    //忽略大小写后再判断字符串是否一样    
          byte[] getBytes()                          //返回当前字符串在默认编码下对应的字节数组    
          byte[] getBytes(String charsetName)        //返回当前字符串在指定的charsetName 编码下对应的字节数组    
 /*说明: byte[] bytes = s.getBytes()    byte[] gbks = s.getBytes("GBK");  
[72, 101, 108, 108, 111, -27, -118, -88, -27, -118, -101, -24, -118, -126, -25, -126, -71]  utf-8
[72, 101, 108, 108, 111, -74, -81, -63, -90, -67, -38, -75, -29]                            GBK  */
           int indexOf(String str)                   //返回str在当前字符串中第一次出现的索引值
           int lastIndexOf(String str)               //返回str在当前字符串中最后一次出现的索引值
           String substring(int beginIndex)          //返回当前字符串从 beginIndex 位置开始的子串
           String substring(int beginIndex, int endIndex) //返回当前字符串[ beginIndex, endIndex)范围的子串    
           String replace(CharSequence target, CharSequence replacement)       
/*把当前字符串中的target使用 replacement替换掉,返回一个新字符串,原来字符串不变    String s1=s.replace("l","*");*/
           String[] split(String regex)             
/*使用regex把当前字符串拆分,拆分后的字符串组成数组  String[] s2 = s.split(",");     */
           char[] toCharArray()                      //把字符串转换为字符数组
           String toLowerCase()                      //把字符串中的大写转换为小写,返回新字符串
           String toUpperCase()                      //把字符串中的小写转换为大写,返回新字符串   
           String trim()                             //去掉字符串前后的空白符,返回新字符串,原来字符串不变   
           String valueOf(int[] i)                     // 把其他类型的数据转换为字符串
           String valueOf(Object obj)                //把对象转换为字符串   
 /*说明:把对象转换为字符串, 底层调用了stu对象的toString()方法. Student类没有重写toString()方法, 调用从Object类继承来的toString(),返回 全限定类名+"@"+ 哈希码的十六进制*/             
           String repeat(int count)                   //数组重复count复制到新数组中
  ------------------------------------------------------------------------------------------------------------     
    StringBuilder类
    StringBuffer类   
 /*说明:StringBuilder/ StringBuffer称为可变字符串, 即它们的字符序列可以修改区别在于StringBuffer是线程安全的,  StringBuilder不是线程安全的, 但是它执行效率更高 */
        1.构造方法
              new  StringBuilder()                  //创建空字符串, 底层数组默认长度为16
              new  StringBuilder(1000)              //创建空字符串, 通过构造方法指定底层数组的大小, 避免数组频繁扩容
              new  StringBuffer()                   
              new  StringBuffer(1000) 
              StringBuilder(CharSequence seq)        //根据其他字符串创建
        2.常用方法
           StringBuilder  append(String str)                     //字符串连接
           StringBuilder  delete(int start, int end)             //删除
           StringBuilder  insert(int offset, String str)         //插入
           StringBuilder  replace(int start, int end, String str)   //替换
           StringBuilder  reverse()                              //把字符串的字符序列逆序 完全逆序
           String toString()                                     //将字符串输出
              
    Math类
          pow(a,b)           //a的b次方    Math.xxxx();
          abs(x)             //x的绝对值
          random()          //生成[0,1)的整数   公式:(max-min)+min
    System类:
        int[] arraycopy(pv,1,array,2,5)         //pv从1开始复制给array从2开始的长度为五的元素
   包装类:
     Double类
       特有方法
          static long doubleToLongBits(double value)    //可以把double小数的二进制转换为long整数
          static toBinaryString(long)                   //将long整形输出
     Interger类
        特有方法
          static String toBinaryString(int i)     //把十进制整数转换为二进制
          static String toHexString(int i)        //把十进制整数转换为十六进制
    Byte类
    Short类                       
    Long类                       
    Float类                       
    Character类
    Boolean类
      1.所有包装类可以根据基本类型数据创建包装类对象
        包装类 a=new 包装类([类型转化] b);   //把b保存到对象a属性中
      2.Character字符类型外,其他包装类型可以根据String字符串创建
        包装类 a=new 包装类("xxx");
      3.每个包装类都有一组自己的常量
        Integer.MAX_VALUE  最大值      2147483647
        Integer.MIN_VALUE  最小值      -2147483648
        Infinity  无穷大(10/0.0)
        -Infinity , 负无穷大(10/-0.0)
        NaN, Not a Number(0/0.0)
     常用方法:
       拆箱:
        byte byteValue()        
        double doubleValue()
        int intValue()                   //int a=num.intValue();
        char charValue()
        boolean booleanValue()              
       装箱:
       static Double valueOf(double d)    //根据基本类型创建包装类对象   自动装箱
        static Double valueOf(String s)    //根据字符串创建包装类对象, 但是Character没有这个相应 方法 
           
        static int compare(double d1, double d2)   //如果前面第一个数更大返回正数, 相等返回0,  包装类.compare(a,b)
        int compareTo(Double anotherDouble)        //比较两个包装类对象的大小   i1.compareTo(i2)
//所有包装类都实现了Comparable接口, 在比较两个包装类对象的大小时, 其实比较的是包装类对象的value属性值的大小
        static double parseDouble(String s)       //把字符串解析为基本类型数据    字符串要注意格式
        static double parseInt(String s)
    static double parseBoolean(String s)   //底层代码: "true".equalsIgnoreCase(s), 可以把非"true"的字符串都转换为false
       
```

```java
util包
    Scanner类:
          nextInt()               //输入int
          nextInt(radix)          //输入一个radix进制的数字,自动转换为十进制 
          nextByte(radix)         //同上
          nextLong(radix)         //同上
          nextDouble()            //输入double
          nextFloat()             //输入float
          next()                  //输入字符串
          next().charAt(0)        //输入char字符                
-------------------------------------------------------------------------------------------------------
               
 Arrays类: -->//不需要new对象    
          toString(array)                    //将array数组输出
   array= copyOf(array,ints.length+ints.length/2)   //将数组扩容,根据需求
      px= copyOf(array,4,8,)                 //将array数组的[4,8)的值复制给px数组
          copyOfRange(array,1,5)             //将数组的[1,5)复制到指定数组
          sort(array)                        // 将array进行排序
          sort(array,1,8)                    //将[1,8)进行部分排序
              //如果是对象的排序,则需要调用Compareble<T>接口,进行排序的方法
              //重写equals只能判断是否相等
          binarySearch(array,key)            //二分查找array中,与key相等的元素的索引值,如果没有则返回-1
          binarySearch(array,5,8,key)       //查找array中[5,8),与key相等的元素的索引值,如果没有则返回-1
          fill(array,10)                
          fill(array,5,8,455)                //将[5,8)赋与455
          equals(array,array1)               //俩个指定数组的类型,长度,元素值是否都相等  字符串的equals方法自动重写
          hashCode(array)                    //返回数组的hash值
------------------------------------------------------------------------------------------------
     
     Random类:-->//需要new对象
          nextInt()             //生成随机整数
          nextDouble()          //生成随机小数
          nextInt(limit)        //生成[0,limit)范围内的整数
          nextInt(a,b)          //生成[a,b)范围内的随机整数
          
------------------------------------------------------------------------------------------------          
     Date类:--> //需要new对象    
         Date date = new Date();       //返回的date技术当前时间值
         Date date1 = new Date(long millis );  //通过构造方法参数指定从1970-1-1 00:00:00 经过的毫秒数
         getTime()                   //距离 1970-1-1 00:00:00 经过的毫秒数
         System.currentTimeMillis();    //获取当前距离 1970-1-1 00:00:00 经过的毫秒数
     SimpleDateFormat类
          SimpleDateFormat sdf = new SimpleDateFormat("String pattern"); //指定的日期格式 yyyy-MM-dd HH:mm:ss
          format( Date )            //可以把对象转换为字符串
          parse(String)             //把字符串解析为Date对象  抛出异常,格式必须满足定义的
------------------------------------------------------------          
     Calendar类:-->//抽象类,调用静态方法getInstance()调用
         Calendar calendar = Calendar.getInstance();
         get(int field)              //返回指定字段值,1年2月5日11小时12分钟13秒          
         calendar.get( Calendar.SECOND )      //Calendar.SECOND(秒)
   //字段Calendar.YEAR  Calendar.MONTH  Calendar.HOUR(12小时) Calendar.HOUR_OF_DAY(14小时制) Calendar.MINUTE         
-----------------------------------------------------------------------------------------------   
             
  Timer类     -->定时器 
     Timer timer=new Timer();
     Timer timer=new Timer(true);    //设置此定时器为守护线程   
     1.timer.schedule(task,time)
     2.timer.schedule(task,delay)   
     3.timer.schedule(task,time,period)  从某刻开始,周期为period
         
       timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println(System.currentTimeMillis());
            }
        }, new Date(System.currentTimeMillis()+5000),3000);
```

```java
text包
   DecimalFormat类  -->//格式化字符串
      public static void main(String[] args) {
        //调用 DecimalFormat(String pattern)  构造方法创建对象
        DecimalFormat df = new DecimalFormat("###,###.0000");
        //format( double ) 把小数转换为字符串
        String sa = df.format(1234.56);
        System.out.println( sa);            //1,234.5600

        sa = df.format(45678912.456789);
        System.out.println( sa );           //45,678,912.4568  四舍五入

        //重新设置模式串
        df.applyPattern("000,000.####");
        sa = df.format(1234.56);
        System.out.println( sa);            //001,234.56

        sa = df.format(45678912.456789);
        System.out.println( sa );           //45,678,912.4568
    }
```

```java
math包
   Math类 -->//不需要new对象
     Double random()      //生成随机小数
     max()                //返回俩个数中较大的
     min()                //返回俩个数中较小的
     int round(x)         //四舍五入,把x+0.5后向下取整
     int ceil(x)          //大于等于x的最小整数
     int floor(x)         //小于等于x的最大整数
     sqrt(a)              //a的平方根
     cbrt(b)              //b的立方根
     pow(a,b)             //a的b次方
  -------------------------------------------------------------------------------
   //为什么有这个出现:   java中计算小数会丢失精度,且范围有限
   BigInteger类(整数)  --> //需要new对象
   BigDecima类(小数)
     BigInteger b=new BigInteger("xxxx");
     b.add(a)                      //将a中的BigInteger类对象与b相加
     b.substract(a)                //b-a
     b.multiply(a)                 //a*b
     b.divide(a)                   //b/a
     b.remainder(a)                //b%a
   //大的小数相除时, 通常调用divide(divisor除数, scale保留小数的位数, roundingMode尾数的处理方式)重载
----------------------------------------------------------------------------------
  枚举类
    public static void main(String[] args) {
        //给枚举变量赋值枚举常量值
        Season s = Season.SPRING;
        System.out.println( s );
        //获得所有的枚举常量   静态常量字段  通过类名.valueOf() 来访问
        Season[] values = Season.values();
        for (Season value : values) {
            System.out.print(value + "    ");
        }
        System.out.println();
        String str = "SUMMER";
         //有助于防止由于输入错误或不一致的字符串表示而导致的错误
        s = Season.valueOf( str );      //把字符串转换枚举常量
        System.out.println(s );
    }
enum  Season{
    SPRING, SUMMER, AUTUMN, WINTER   ;       //定义Season枚举类型的常量值
}      
```

```java
time包
   // JDK8新增的线程安全的日期API
   LocalDateTime类-->//LocalDateTime类的构造方法是private私有的, 不能直接new对象, 调用它的静态方法now()创建对象
      LocalDateTime localDateTime = LocalDateTime.now();   //localDateTime现在的时间
      static of(year, month, day, hour, minute, second)   //调用of()静态方法创建对象(指定的时间)
     getYear()                    //年月日时分秒
     getMonthValue()     
     getDayOfMonth() 
     getHour()
     getMinute()     
     getSecond()
     format( DateTimeFormatter )       //可以把对象转换为指定格式的字符串
     parse(CharSequence s, DateTimeFormatter)   //把字符串解析为LocalDateTime对象 
 DateTimeFormatter类
     DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss"); //指定日期格式      
```



## Java常用接口

```java
1.Comparable<T>接口
     
    @Override
    public int compareTo(T o) {
        if (this.age > o.age) return 1;
        if (this.age < o.age) return -1;
       return 0;
    }
    当一个类实现Comparable接口时, 给泛型参数T传递一个数据类型, 这个类型就是抽象方法compareTo的参数类型,这个类型就是另外一个比较对象的类型
     Arrays.sort()方法,自动调用compareTo()的底层比较方法,如果是对象值的比较则要重写此方法
2.Comparator<T>接口
        静态方法:naturalOrder()
                reverseOrder()
                comparing()
            Comparator.comparing(new Function<Student, Integer>() {  //有对象
            @Override
            public Integer apply(Student student) {
                return (int) student.getScore();
            }
        })
         @Override
            public int compare(String o1, String o2) {
                return o2.compareTo(o1);        //o1更大返回负数,对应由大到小的降序排序
            }
3.Consume<T>接口    //接收数据并对数据进行处理  forEach(Consumer<? super T> action)
      public interface Consume<T>{
        void accept(T t){
             System.out.println( t);
        }
}
4.Predicate接口   //测试接收的数据进行处理    removeIf(Predicate<? super E> filter)
    public interface Predicate<T>{
        boolean test<T t>{
            return t.length()==4;
        }
}
5.Function接口     //对接收的T类型的数据进行处理,并返回一个R类型的结果    Comparator.comparing(new Function<String, Integer>()
    public interface Function<T,R>{
        R apply(T t)
            return t.length();
        }
}
6.Supplier接口   //封装功能返回一个T类型的对象
    list.stream().collect(Collectors.toCollection(new Supplier<TreeSet<String>>()  //list流转TreeSet
    public interface Supplier<T>{
       T get();
}
7.ToIntFunction接口    
  Double avg=list.stream().collect(Collectors.averagingInt(new ToIntFunction<String>() {
            @Override
            public int applyAsInt(String value) {
                return value.length();
            }
        }));  //计算list 集合中xxx的平均值
8.IntFunction<String[]>
         list.stream().toArray(new IntFunction<String[]>() {
            @Override
            public String[] apply(int value) {
                return new String[value];
            }
             
```



## UML类图

![image-20240407191344238](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240407191344238.png)

![image-20240407191401116](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240407191401116.png)

## 集合(容器)

```java
概念:数组是存储同类型若干数据的容器,数组可以存储基本数据类型,也可以存储对象
     集合是存储引用对象的氢气,在集合中只能存储对象,不能存储基本数据类型
     在实际开发中更多使用集合,集合使用更方便
1.Collection集合  ->单个数据存储,也称单列集合
    概念:Collection是个接口,实现类才是存储数据的容器,定义了一组集合的操作规范
   01.Collection接口
    创建对象: Collection collection = new ArrayList()
              Collection collection = new LinkList()
              Collection collection = new Vector()  //线程安全
              Collection collection1 = new HashSet();
              Collection collection1 = new TreeSet(); 
     方法1:
         add()                 //添加数据,若无泛型指定数据类型,则可以添加任意
         size()                //集合大小
         isEmpty()             //是否为空
         contains("xxx")       //是否包含xxx字符串
         remove(Object o )     //从集合中删除第一个与o匹配的元素, 删除成功返回true
         clear()               //清空    
         addAll( c )           //可以把参数c集合中的所有元素添加到当前集合中  collection.addAll(list)
         containsAll( c )      //判断当前集合是否包含参数c集合中所有的数据
         retainAll( c )        //保留在参数c集合中有的数据, 不在参数c集合中的数据就删除
         removeAll( c )        //把包含在参数c集合中的数据都删除
        Object[] array = collection.toArray();  //集合转数组
---------------------------------------------------------------------------------------------------------------
         println(list)  自动调用string的valueof(Object obj)方法,调用obj.toString():
                         return getClass().getName() + "@" + Integer.toHexString(hashCode());
          但ArrayList extends AbstractList  extends AbstractCollection   
             AbstractCollection有重写了toString()方法:
               public String toString() {
                Iterator<E> it = iterator();
                if (! it.hasNext())
                 return "[]";

              StringBuilder sb = new StringBuilder();
              sb.append('[');
             for (;;) {
                E e = it.next();
               sb.append(e == this ? "(this Collection)" : e);
               if (! it.hasNext())
                   return sb.append(']').toString();
              sb.append(',').append(' ');
             }
          }
---------------------------------------------------------------------------------------------------------------
      方法2:
         removeIf(Predicate<? super E> filter)   //方法可以删除符合条件的多个元素
             list.removeIf(new Predicate<String>() {
                @Override
              public boolean test(String s) {
         //Predicate接口抽象方法test的参数s用于接收前面collection集合的每个元素, test方法就测试接收的数据是否满足某个条件
                return  s.length() == 4;
               }
            })
         foreach(Consumer<? super T> action)             //遍历集合的每一个元素 
             list.forEach(new Consumer<String>() {
                    @Override
                       public void accept(String s) {
                    //Consumer接口中抽象方法accept的参数 用于接收前面collection集合的每个元素
                      System.out.println( s );
                       }
      迭代器:
       创建对象:
         for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {
            String next = it.next();
            System.out.print( next + "  ");
        }
         hasNext()           //判断是否还有下个元素
         next()               //返回下个元素  游标下移
         remove()             //删除刚刚next()返回的元素
 /*说明: Collection集合底层定义了一个计数器变量modCount, 统计调用collection集合add()添加元素, remove()删除元素的次数,  即每次调用collection.add(o), collection.remove(o)时 modCount都自增,通过Iterator迭代器遍历集合中元素期间,会检查 modCount的值是否发生变化,如果检测到modCount的值变了就会抛出java.util.ConcurrentModificationException并发操作异常*/     
        迭代遍历,使用迭代器的remove()删除多个符合条件的数据  
    for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {
            String next = it.next();
            if ( next.contains("o")){
                it.remove();        //删除刚刚next()返回的元素
            }
        }
------------------------------------------------------------------------------------------
  02.list接口
    概念:Collection有的操作List都有,有序可重复
    增加方法:
      add( i , o )            //在list集合的i位置添加元素o
      get( i )                //返回list集合中i位置的元素
      set( i, o )             //把list集合中i位置的元素修改为o 
      indexOf( o  )           //返回o元素在list集合中第一次出现的索引值
      remove( i )             //把list集合中i位置元素删除并返回
      subList(from, to )      //返回list集合中[from, to)范围内元素的视图   对原先的list是相同操作
      List.of(list1,list2,xx,aa,yy)
      sort()排序
         1. list.sort(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.compareTo(o1);        //o1更大返回负数,对应由大到小的降序排序
            }
        });
           2.list.sort( new StringCMP() );
 
        static class StringCMP implements Comparator<String>{
           @Override
          public int compare(String o1, String o2) {
            return o1.compareTo(o2);            //o1更大时返回正数, 在排序时对应由小到大的升序
        }
    }
    list迭代器:(从后往前)
    增加方法:
      hasPrevious()          //判断游标前面是否还有元素
      add()                  //在游标的位置添加元素
      set()                  //修改刚刚返回的元素
      revious()               //返回游标前面的元素,游标向前移
 ---------------------------------------------------------------------------------------
   03.LinkedList
       概念:Collection和list有的操作LinkedList都有
       增加方法:    //模拟队列,栈
           offer()         把元素添加到链表尾部
           poll()          链表第一个元素删除并返回
           peek()          链表第一个元素返回,不删除
           push()          把元素添加到链表头部
           pop()           链表第一个元素删除并返回
           getFirst()      获取第一个元素
           peekfirst()     获取第一个元素
           getLast()       获取最后一个元素
           peekLast()      获取最后一个元素
           removeFirst()   删除第一个元素
           pollFirst()     删除第一个元素
           removeLase()    删除最后一个元素
           pollLast()      删除最后一个元素
           addFirst()      添加到第一个元素
           offerFirst()    添加到第一个元素
           addLast()       添加到最后一个元素
           offerLast()     添加到最后一个元素
------------------------------------------------------------------------------------------
     03.set
        概念:Collection有的操作set都有,且set是无序,不可重复的
        创建对象:  Set<String> set = new HashSet<>( )
                  Set<String> set2 = new HashSet<>( set )
                  Set<String> set2 = new TreeSet<>( set )   //排序方法
            
      04.HashSet
         概念:HashSet集合中元素的存储位置是由元素的哈希码计算出来的, 判断元素是否重复调用equals方法
              Student类从Object类继承了equals方法,  使用关系运算符 == 判断相等 
              Student从Object继承了hashCode方法, 返回的整数可以简单的看作是堆中对象的引用
      05.TreeSet
           TreeSet集合实现了SortedSet接口,可以对集合中的元素进行排序,需要比较元素的大小
             1.可以在TreeSet的构造方法中指定Comparator比较器
             2.如果没有在构造方法中指定Comparator,要求元素本身具有比较大小的功能,即要求元素的类要实现Comparable接口
            treeSet1.addAll(treeSet2)    //treeSet2的所有元素添加到treeSet1中并且按1的排序进行存储
          排序:
           TreeSet<String> treeSet = new TreeSet<>(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.compareTo(o1);        //o1更大 返回负数
                //return (o2.name).compareTo(o1.name)
            }
        });
         
        static  class Student implements Comparable<Student>{
        String name;
        int score;
        @Override
        public int compareTo(Student o) {
           // return 0;
            return this.name.compareTo(o.name);
        }     
     }       
            
------------------------------------------------------------------------------------------
 Collections 工具类
    1.Arrays.asList(T...data)       
            说明: 可以把若干数据转换为List集合,形参变长参数可以接收任意多个数据,这个List集合不支持添加与删除, 可以修改
            举例: List<Integer> integerList = Arrays.asList(ints,1, 23, 56, 98, 74, 33);
            set(index,x)    //设置index位置为x值
    2. static <T> boolean addAll(Collection<? super T> c, T... elements)
            说明: 向c集合中同时添加若干数据.在返回值类型boolean前使用<T>声明泛型参数,  addAll方法第一个参数collection存储T类型或者T父类对象, addAll第二个变长参数T类型
            举例: Collections.addAll(list, "xiaoming", "xiaobai", "chen", "sun", "flower", "girlfriend");  
     3.static void reverse(List<?> list)  
           说明: 对list集合中的元素逆序
           举例: Collections.reverse(list);
     4.static <T extends Comparable<? super T>> void sort(List<T> list) 
           说明: 对list集合中的元素进行排序,要比较集合中元素的大小, 即要求元素的类要实现Comparable接口. 在void返回值类型前面声明泛型参数<T extends Comparable<? super T>>表示T类要实现Comparable接口
           举例: Collections.sort(list);
     5.static void shuffle(List<?> list)   
           说明: 对list集合中的元素乱序
           举例: Collections.shuffle(list);   
     6.static <T> void sort(List<T> list, Comparator<? super T> c)  
           说明: 对list集合中元素排序, 使用指定的c比较器
           举例:Collections.sort(list, Comparator.comparing(String::length).reversed());
                Collections.sort(list, Comparator.reverseOrder());
     7.static <T> List<T> synchronizedList(List<T> list)  
           说明: 把不是线程安全的集合转换为线程安全的
           举例: List<String> synchronizededList = Collections.synchronizedList(list);
-----------------------------------------------------------------------------------------
```

![image-20240414144408326](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240414144408326.png)

![image-20240414145403591](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240414145403591.png)

![image-20240407195650397](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240407195650397.png)

![image-20240408202755574](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240408202755574.png)

```java
2.Map集合   ->按键值对形式存储,也称双列集合
    HashTable:底层数据结构是哈希表,它是线程安全的
    Properties:是一种线程安全的Map集合,键值多少固定的字符串,经常用于读取程序的属性
    HashMap:底层的数据结构是哈希表(散列表),它其实是一个数组,数组元素是链表,结合了数组与链表的优点
    TreeMap:实现了SortMap接口,可以根据键排序,键是根据红黑树原理进行的排序
    创建:
        Map<K, V> map = new HashMap<>(); 
        Map集合中的键不允许重复,在put(k,v)添加键值对时,如果map集合中已存在k键,则把map集合中k键的值替换成v,并返回旧v值
    方法:
       put(K,V)            //添加成功则返回null
       size()              //大小
       isEmpty()           //是否为空
       get(K)              //返回k对应的value值,不存在则返回null
       containsKey(k)       //是否包含k键
       containsValue(v)     //是否包含Value值
       keySet()             //返回所有的k键对
       values()             //返回所有的value值
       entrySet()           //返回所有键值对
  /*返回所有Entry的集合, Entry就是一个键值对, Entry的类型是: Map.Entry, 表示Entry是Map接口中定义的内部接口
  类名1.类名2  形式时, 表示类名2是类名1的内部类*/
       Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
                 [guoliu=90, sunba=80, lisi=90, hanyi=60, zhangsan=90, wangwu=40, chenqi=100]
                 {guoliu=19, sunba=80, lisi=90, hanyi=60, zhangsan=90, wangwu=40, chenqi=100}
       replace(k ,v )      //把map集合中k键的值替换为v,返回被替换掉的value值
       remove(k )          //从map集合中删除k键对应的键值对, 删除成功返回这个键值对的value值
       forEach(BiConsumer<? super K,? super V> action)    //遍历Map集合的每个Entry
           map.forEach(new BiConsumer<String, Integer>() {
            @Override
            public void accept(String s, Integer integer) {
                //BiConsumer接口accept抽象方法的第一个参数接收map集合中Entry的键, 第二个参数接收Entry的值
                System.out.println( s + " : " + integer);
             }
          });
     getOrDefault(Object key, V defaultValue)   //返回map集合中key键的值,如果map集合中不存在key键则返回自定义默认值
     putAll(Map<? extends K,? extends V> m)     //把参数m集合中的所有键值对都添加到当前集合中 map2.putAll(map )
     putIfAbsent(K key, V value) //如果map集合中不存在key键,向map集合中添加<key,value>, 如果map集合中存在key键就不添加
         
    /* map.keySet()是map集合中所有键的映射,  map.values()是map集合中所有value值的映射,   map.entrySet()是map集合中所有Entry的映射,  这些方法并没有创建新的集合, 从这个方法返回的集合中删除数据其实就是从map中删除数据*/
     map2.values().removeIf( s -> s < 90 );      //从map.values()集合中删除
     map.of(map1,map2,"ss",vv)
----------------------------------------------------------------------------------- 
 01.HashMap
   解决哈希冲突的方法:
      1.拉链法       如图
      2.寻址法       依次往后寻找空位
      3.多重哈希法
   JDK8对HashMap的改进:
      1.尾部增加结点   (JDK之前在头部)
      2.当链表中结点数量超过8时,会自动转换为红黑树(几率很小,基本为扩容)
      3.扩容概念:
         (1) 当链表结点超过8时,如果数组长度小于64,先对数组扩容,数组长度大于等于64时,把链表转换为红黑树(提高效率)
         (2) HshMap底层哈希表默认长度为16,默认按2倍大小扩容
         (3) 当哈希表中的结点(总结点)的数量>数组*加载因子(0.75)时,进行扩容(16*0.75=12)
    扩容实现方法:
       1.把原来数组的结点复制到这个更大的数组中,如果只有一个结点,就根据这个结点的hash值重新计算下标
       2.如果多个结点,遍历链表的每个结点,把这些结点分为loHead,hiHead俩个链表分组依据是:
           hash & 数组长度 结果不是0分到hiHead链表中,结果为0的分到loHead链表中 
 02.HashTable
    特点:
      1.底层数据结构是哈希表,它是线程安全的,HashMap不是线程安全的
      2.初始化容量:11  HashMap初始化容量为16
      3.加载因子0.75,当键值对的数量>数组长度*加载因子时,进行扩容
      4.按2倍+1扩容,HashMap按2倍大小进行扩容
      5.都可以指定初始化容量,HashMap会把初始化容量调整为2的幂次方
      6.键值都不允许为null,HashMap的值可以为null
 03.properties
   特点:
      1.Properties继承了HashTable,是一种线程安全的Map集合
      2.Properties的键值多少固定的String字符串
      3.setPropety(属性名,属性值)用于设置属性,其实就是map集合的put操作
      4.getProperty(属性名)用于设置属性值,其实就是map集合的get操作
   应用:
      有什么可能需要读取系统属性,调用System.getProperty(属性名)
          user.name
          user.home
          user.country
    //获得所有系统属性
        Properties allProperties = System.getProperties();
        allProperties.forEach((k,v) -> System.out.println( k + " ----- " + v ));
  resources资源包:
     第一种:
  public static void main(String[] args) throws IOException {
        //1 创建Properties对象
        Properties properties = new Properties();
        //2 使用类加载器建立与属性文件之间的输入流通道
        //运行java程序,启动JVM, JVM的类加载器会把字节码加载内存, 通过.class字节码获得它的类加载器, 调用类加载器的方法与属性文件建立输入字节流通道
        InputStream in =Test03Properties.class.getClassLoader().getResourceAsStream("resources/config.properties");
        //3 加载调用Properties的load(InputStream)方法
        properties.load(in);
        //4 读取属性
        System.out.println( properties.getProperty("username"));
        System.out.println( properties.getProperty("password"));
        System.out.println( properties.getProperty("国籍"));      //如果出现乱码说明属性文件编码与当前环境编码不一致
        System.out.println( properties.get("username"));
        System.out.println( properties.getProperty("country"));     //null,属性名不正确
        //5 关闭流
        in.close();
    }
    第二种:
 public static void main(String[] args) {
  //创建 ResourceBundle对象, 调用 ResourceBundle 类的静态方法getBundle(属性文件基础路径), 注意属性文件基础路径不需要扩展名
        ResourceBundle resourceBundle = ResourceBundle.getBundle("resources/config");    
        //调用 实例方法 getString(属性名) 可以读取属性
        System.out.println(resourceBundle.getString("username"));
        System.out.println(resourceBundle.getString("password"));
        System.out.println(resourceBundle.getString("国籍"));
        //System.out.println(resourceBundle.getString("country"));        //属性名不正确也会抛出异常
    }
04.TreeMap
    概念:
        1.TreeMap实现了SortMap接口,可以根据键排序,需要比较键的大小,可以在TreeMap构造方法中指定Comparator比较器,如果构造方法没有指定Comparator则要求键本身具有比较大小的功能
        2.TreeMap只能根据键排序, 不能根据值排序 
        3.TreeMap的排序原理是红黑树
    方法:
     firstKey()        //获取第一个键值对的k
     firstEntry()      //获取第一个键值对的v
     lastKey()         //获取最后一个键值对的k
     lastEntry()       //获取最后一个键值对的v
     pollFirstEntry()    //删除第一个键值对
     pollLastEntry()     //删除最后一个键值对
```

![image-20240414180346212](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240414180346212.png)

![image-20240414181910939](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240414181910939.png)

![image-20240414182048598](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240414182048598.png)

```java
Map和Set的关系
   概念:
     1.HashSet底层数据结构是HashMap
     2.向HashSet集合中添加数据,其实就是把数据作为键添加到底层的HashMap中
     3.HashSet就是HashMap键的集合
         
     1.TreeSet底层数据结构是TreeMap
     2.向TreeSet集合中添加数据,其实就是把数据作为键添加到底层的TreeMap中
     3.TreeSet就是TreeMap键的集合
Map键值数据类型:
   HashMap概念:
     HashMap集合底层数据结构是哈希表,键值对的存储位置是由键的哈希码计算出来的,如果修改了键对象的属性,导致键对象的哈希码变化,进而导致计算出来的数组下标不一致了
     在 put(k,v)添加键值对时,根据k键的哈希码计算出来数组下标i=11,,把<k,v>对添加到table[11]链表中
     修改k键的属性,导致k键的哈希码变化(实际存储还是在原先table[i]中)
     在调用get(k)方法时,根据k键现在的哈希码计算出来的数组的下标i=13,去table[13]链表中查找,找不到
  TreeMap概念:
     TreeMap的键是根据红黑树原理实现排序的, 红黑树是一棵自平衡二叉搜索树
     在put添加键值对时, 根据键对象现在的大小把它添加到某个结点的右(左)子树上
     修改了键对象的排序字段值(实际存储还是原先的二叉树位置)
     再查找时, 可能会去这个结点的左(右)子树上查找, 找不到(修改的字段值与根结点比较)
         
Map的value值自定义
    value值是引用: Map<Integer, Student> map = new HashMap<>();
    value值是list集合: Map<String, List<String>> map = new HashMap<>();
List集合中存储其他的集合
      List<List<String>> listList = List.of(list1, list2, list3);
      List<Map<String, Integer>> mapList = List.of(map1, map2, map3);
```

![image-20240414191855741](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240414191855741.png)

![image-20240414192626209](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240414192626209.png)

## Lambda表达式与Stream流

```java
1.自定义泛型
    01.可变长泛型参数
    addAll(list,12,14,15);
    private static <T> void addAll(List<T> List, T... date) {
        for (T d : date) {
            List.add(d);
        }
    }
    02.如果在使用泛型类, 泛型接口时, 没有显示的给泛型参数传递数据类型,则系统默认 为Object类型
        Genric obj3=new Genric();
        obj3.setDate(new Object());
        Object data=obj3.getDate();
        System.out.println(data);
 class Genric<T>{
    private T date;
    public T getDate() {
        return date;
    }
    public void setDate(T date) {
        this.date = date;
    }
}  
  03.泛型参数只能传递引用类型,不能传递基本类型 <T>  也可以有多个泛型参数
      public interface Map<K,V>{
         V put(K key,V value);
   }
  04.泛型通配符
      <?> 不确定什么类型,或者什么类型都可以,跟类型无关
      <? extends T>表示 T类型或者T的子类
      <? super T> 表示T类型或者T的父类
      <? extends 接口> 表示接口的实现类
 2.Lambda表达式
  概念:{参数列表}->{Lambda体}    类名(对象名)::方法名
        (s1,s2,..)->s1.compareTo(s2)   String::compareTo
  方法引用类型:
    (1) 当Lambda体就是调用了某个类(对象)的方法时, 可以使用方法引用的形式
    (2) Lambda体是调用类的无参构造创建对象时, 可以使用方法引用
    (3) Lambda体创建数组, 数组的长度是Lambda参数接收的数据
 3.Stream流
    (1)生成Stream流
      1.1 在int[],string[] T[]上生成Stream流,调用Arrays.stream(数组名)
           int[] ints={56,23,445,69};
           IntStream intStream= Arrays.stream(ints);
      1.2在Collection集合上生成Stream流,调用Collection集合的stream()方法
          List<String> list=new ArrayList<>();
          Collections.addAll(list,"hello","girl","boy","girlfriend");
          Stream<String> listStream=list.stream();
      1.3调用Stream接口提供的静态方法创建Stream流
          1.3.1   静态方法    若干流
             Stream<String> staticFunctionStream = Stream.of("hello", "nice", "what");
          1.3.2    静态接口   无限流
             Stream<Integer> InterfaceStream = Stream.generate(new Supplier<Integer>() {
                @Override
            public Integer get() {
                return new Random().nextInt();
            }
        });
         1.3.3  seed种子迭代的无限流
             Stream<Integer> seedStream = Stream.iterate(2, new UnaryOperator<Integer>() {
                 @Override
                public Integer apply(Integer x) {
                return x + 3;
            }
        });
    (3)终端操作
      3.1 Stream<T> filter(Predicate<? super T> predicate) 筛选符合predicate条件的元素
        list.stream().filter(new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.length()>=5;
            }
        }).forEach(s-> System.out.println(s+" "));
       3.2 <R> Stream<R> map(Function<? super T,? extends R> mapper) 映射, 对流中的每个元素执行mapper操作
          list.stream().map(new Function<String, String>() {
            @Override
            public String apply(String s) {
                return s+"666";
            }
        }).forEach(s-> System.out.println(s+" "));
        3.3 Stream<T> distinct() 去掉流中重复的数据
          list.stream().distinct().forEach(s-> System.out.println(s+" "));
        3.4 Stream<T> limit(long maxSize) 截取前maxSize个元素
          list.stream().limit(5).forEach(s-> System.out.println(s+" "));
          Stream.generate( () -> new Random().nextInt() )
                .limit(1000)
                .forEach(s -> System.out.print(s + "  "));
        3.6 Stream<T> sorted(Comparator<? super T> comparator) 使用参数指定的comparator比较器排序
          list.stream()
                .sorted(Comparator.reverseOrder())
                .forEach(s -> System.out.print(s + "  "));
        System.out.println();
     3.7 <R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper) 当流中元素是其他的容器时, 把这些容器中的数据取出来组成一个新的Stream流
        List<String> list2 = List.of("aaa", "bbb", "cccc", "ddddd");
        List<String> list3 = List.of("xxx", "yyy", "zzz");
        Stream.of( list1, list2, list3)     //流中的元素是List集合
                .flatMap(List::stream )     //调用流中list集合的stream方法
                .forEach(s -> System.out.print(s + "  "));
        list.stream()
                .map( s -> s.split(""))     //对流中的每个字符串使用""空串拆分
                .flatMap( Arrays::stream)     //对流中的每个 String[]数组调用Arrays类的stream方法把数组元素生成Stream流
                .forEach(s -> System.out.print(s + "  "));
    
    (2)中间操作
      2.1  遍历流中每一个元素
         staticFunctionStream.forEach(System.out::println);
      2.2  list集合Stream流生成Collections
          String str=list.stream().collect(Collectors.joining("-")); //list集合Stream流 转字符串
          Set<String> set=list.stream().collect(Collectors.toSet());    //list集合Stream流转set集合
          List<String> list1=Arrays.stream(data).collect(Collectors.toList()); //数组Stream流转list集合
          TreeSet<String> treeSet=list.stream().collect(Collectors.toCollection(new  Supplier<TreeSet<String>>() {
               @Override
               public TreeSet<String> get() {
                  return new TreeSet<>();
              }
             }));    //list集合Stream流转TreeSet集合
          Double avg=list.stream().collect(Collectors.averagingInt(new ToIntFunction<String>() {
              @Override
               public int applyAsInt(String value) {
                  return value.length();
               }
            }));  //计算list 集合中xxx的平均值
        Map<Integer,List<String>> map=list.stream().collect(Collectors.groupingBy(new Function<String, Integer>() {
            @Override
               public Integer apply(String s) {
                  return s.length();
              }
            }));    //list集合的Stream流转map集合
      2.3  是否包含某个字符串
         boolean flag = listStream.allMatch(new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.contains("e");   //是否包含e
            }
        });
       2.4 统计元素
        long count = list.stream().count();
      2.5排序比教 返回最大或最小
        Optional<String> max = list.stream().max(Comparator.naturalOrder());
        System.out.println(max.orElse(""));//orElse:默认为空时返回的数
        max=list.stream().max(Comparator.reverseOrder());
        System.out.println(max.get());   //max.isPresent();
        Optional<String> min = list.stream().min(Comparator.comparing(String::length));
    2.6  Object[] toArray() 把流中数据保存到数组中
        Object[] array = list.stream().toArray();
        String[] strings = list.stream().toArray(new IntFunction<String[]>() {
            @Override
            public String[] apply(int value) {
                return new String[value];
            }
        }); 
```



## 异常

```java
Throwable:所有异常的父类
    Error:JVM的错误,开发人员无法处理
    Exeption:开发人员可以处理的异常
       编译异常:检查异常,没有继承RuntimeException类,用户网络等等,必须预处理
       运行异常继承RuntimeException,运行时异常,不需要预处理
  实现: 
   throws 类定义时抛出
   try{ }catch{ }finnal{}
catch里面有俩种类型的抛出错误:
   e.printStackTrace();                可执行后面程序
   throw  new RuntimeException(e);     不可执行后面程序
自定义异常:
  类 extends Exception  
  类 extends RuntimeException
编译异常方法必须要先预处理 即throws xxx
实现过程:
   public void setAge(int age) throws AgeOutOfBoundsException {
       if(age>=0&&age<=100){
           this.age=age;
       }else {
           throw new  AgeOutOfBoundsException(age+"超出范围了");
       }
    }
如果其他类调用此类方法,那么也要进行抛出异常
---------------------------------------------------------------------------------------
方法覆盖(重写规则)
    1.类名,参数列表必须相同
    2.返回值可以相同,也可以是子类型
    3.访问权限可以相同,也可以更广泛
    4.抛出异常可以相同也可以更小
        父类中没有抛出异常则子类也不能抛出异常,出现编译异常时,只能try 捕获异常
        父类中也抛出异常则子类可以抛出异常,也可以try捕获异常

```

![image-20240411212203032](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240411212203032.png)

## IO流/文件

```java
如果outputStream/writer的文件不存在则会自动创建,追加/覆盖方式
1.FileInputStream/FileOutputStream
  创建:
     FileInputStream fis = new FileInputStream("D:\\course-dljd\\file\\test.txt");
     FileOutputStream fos=new FileOutputStream("D:\\course-dljd\\file\\out.txt",true);//true表示追加
  方法:
     fis.read()           
     fis.read(byte[])         //读到此容器中
     len=fis.read(byte[])    //返回-1则说明读到底,否则返回最后读到的长度
     write()        //写文件    可以是整数也可以是字节数组
------------------------------------------------------------------------
优化了fileinputStream和fileoutputStream,它是将字节传送缓冲到一个池中,待close()或者flush()或者池满才会进行与内存的操作
2.BufferedInputStream/BufferedOutputStream
   创建:
      BufferedInputStream bis = new BufferedInputStream(new FileInputStream("xx\\buffered.txt")
      BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("xx\\buffered.txt")
   方法:
     read()    read(byte[])   flush()   write()
------------------------------------------------------------------------
可以指定存储的字节类型,读取指定的字节类型,如中文(三个字节),英文(一个字节)  局限:必须按照输入的顺序了存取(每一个)
3. DataInputStream/DataOutputStream
   创建: 
       DataInputStream dis=new DataInputStream(new FileInputStream("xx\\data.txt"));                                      DataOutputStream dos = new DataOutputStream(new FileOutputStream("xxx\\data.txt"));
   方法:                                                      
      dos.writeInt(1234);                //可以是对应类型的数组
      dos.writeDouble(12.6);
      dos.writeChar('g');
      dos.writeBoolean(true);
      dos.writeUTF("栈找那个");                                                                                           int i = dis.readInt();
      double v = dis.readDouble();
      char c = dis.readChar();
      boolean b = dis.readBoolean();
      String s = dis.readUTF();  
------------------------------------------------------------------------
4.PrintStream
   创建:
       PrintStream p=new PrintStream(new FileOutputStream("xxx\\print.txt",true));  //true  追加                        方法:                              
       print()
       println()                                                   
   应用:
      1.将打印结果打印到文件中:                                                   
        System.setOut(p);
        System.out.println("打印方向在文件-");
      2.将报错信息打印到文件中:
         try {
            byte[] bytes="动力节点".getBytes("888");       //无8888的编码,系统将会报错
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace(p);                         //将报错结果打印到文件中
        }
------------------------------------------------------------------------
对象序列化与反序列化    Serializable接口    transient瞬态
 private static final long serialVersionUID = 8353819979144095448L;   .class序列化版本号
5.ObjectInputStream/ObjectOutputStream
  创建:
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream("xx\\obj.txt"));
    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("xx\obj.txt"));                                方法:
     writeObject(Object obj)       //将对象序列化
     readObject()                  //对象反序列化                                   
   应用:
   1.对象序列化与反序列化过程:
    Person p1=new Person("zhangsan",18,new Car("su7", 29),"44");
    Person p2=new Person("lisi",28,new Car("保时捷", 108),"1234");
    Person p3=new Person("zhaoliu",38,new Car("biyd", 59),"456987");
    List<Person> list=List.of(p1,p2,p3);                                                      
    oos.writeObject(list);
    //反序列化存储在list集合中  
    List<Person> list= (List<Person>) ois.readObject(); 
    2.Serializable接口:
       只要进行序列化,此对象必须实现Serializable接口                                                   
    3.transient关键字:
       在对象属性前加上此关键字,则此属性为瞬态,不进行序列化,值为null                                                   
    4.序列化版本化
       在定义完一个对象时,.class文件会保存对象的序列化版本号,进行ObjectOutputStream序列化则会生成一个版本号写入txt文件中,调用ObjectInputStream进行反序列吗,会将.class文件保存的序列号与文件中的序列号进行比较,如果相等则可以进行反序列化
       在对象中添加属性,则.class文件会生成另外的序列化版本号,与原先在txt文件中的序列化版本号相比,则会不同,不能进行反序列化
     解决方法:
       在对象定义的类中,添加一个版本号,关联类也要添加                                                  
------------------------------------------------------------------------
 字符流                                                  
 6.fileWriter/fileReader
   创建:
    FileWriter fw=new FileWriter(srcPath,true)                                                      
    FileReader fr = new FileReader(srcPath)                                                      
   方法:                                                       
    write()        //一个字符或者一个字符数组
    read()                                                      
------------------------------------------------------------------------                                            字节->字符->程序->字符->字节     应用在编码不同文件中的读与写
7.InputStreamReader/OutputStreamWriter
  创建:                                                        
    OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(srcPath,true),"ANSI");                           InputStreamReader isr=new InputStreamReader(new FileInputStream(srcPath),"ANSI");                             
  应用:
   fileWriter/fileReader继承了InputStreamReader/OutputStreamWriter就是一个字节流到字符流的转换,默认编码                 8.BufferedReader/BufferedWriter                                      
   创建:                                                       
      BufferedReader br = new BufferedReader(new FileReader(srcPath));
      BufferedWriter bw = new BufferedWriter(new FileWriter(srcPath, true)); 
    方法:
       newLine()    //输入换行 
       readLine()   //读一行数据                                                   
------------------------------------------------------------------------ ---------------------------             
IO流的设计模式
  1.IO流以Filter开头的流类采用了装饰器模式,可以对已有类的方法进行功能扩展
  2.转换流采用了适配器模式,可以让不兼容的接口工作在一起
  3.Collection集合中的迭代器采用了迭代模式,不管底层数据结构是什么,都可以迭代访问集合的每个元素                    
  4.享元模式的目的是为了减少对象创建的数量,双引号起来的字符串字面量保存在字符串常量池中,-128~127范围内的整数自动装箱保存在缓存中                  
  5.策略模式就是同一个接口在不同实现类中实现算法不同,这些算法可以互相替换                                    
------------------------------------------------------------------------ ---------------------------               文件的操作
 1.关联文件
     File f1 = new File("xxx/01.png");                                                 
      File f2 = new File("xxx", "01.png");         
 2.创建/删除文件
     exists()      //判断文件是否存在                                                      
     delete()      // 删除文件
     createNewFile()     //true 表示文件不存在创建成功   false表示文件存在创建失败      
3.查看文件属性        
     getAbsolutePath()    //文件绝对路径
     getName()            //文件名
     isFile()             //是否为文件
     length()             //文件大小
     lastModified()       //文件最后修改时间 与日期共同使用
文件夹的操作
  1.关联文件
      File f1 = new File("xxx/day01");                                                 
      File f2 = new File("xxx", "day01");
      File f3 = new File("xxx", "day01/com/homework/a");
  2 创建/删除文件夹                                                       
     mkdir()          //true 表示文件夹不存在创建成功,false表示文件夹存在创建失败   如果上一级文件夹不存在则也false
     mkdirs()         //解决上一级文件夹不存在,会一起创建     true/false
     delete()         //删除空文件夹                                                     
  3.显示文件夹内容
     File[] files = f4.listFiles();          //返回f4文件夹中所有的内容
        for (File file : files) {
            System.out.println(file);
        }
  4.显示文件夹内容时, 使用 FilenameFilter 文件名过滤器,返回符合条件的内容                                                     files = f4.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                //第一个参数dir接收的是文件夹, 第二个参数name接收的是文件名
                //System.out.println( dir + " --------- " + name);
                return name.endsWith(".png");      //返回后缀为png的文件
            }
        });
   5.文件属性
       isDirectory()   //是否为文件夹 
       getName()        //获取文件/文件夹的名字                                
```

![image-20240411190306082](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240411190306082.png)

## 多线程

```java
线程的相关概念:
   概述:
     1.进程是操作系统的一个概念,进程是计算机运行的一个程序,线程是进程的一个执行单元,线程是进程的一个执行路径
     2.进程是线程的容器
     3.一个程序至少包含一个线程,如果程序只有一个线程称为单线程程序
     4.线程可以是依次执行/并发执行/并行执行(理想状态下)
   优势:
    1.并发执行效率高
    2.等待时间更短,或者说响应更快,如后面Tomcat服务器就是一个多线程程序,可以为每一行用户请求分配一个线程进行响应
    3.充分利用多核心CPU资源
    4.提高程序的健壮性
--------------------------------------------------------------------------------------
线程的三种方法:
  1.定义类继承Thread
public class Test01 {
    public static void main(String[] args) {
        Thread t0=new Thread();
        t0.start();         //未执行
        Thread t=new subThread();
        t.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("main -------->"+i);
        }
    }
}
 class  subThread extends Thread{
     @Override
     public void run() {
         for (int i = 0; i < 100; i++) {
             System.out.println("sub Thread =====> "+i);
         }
     }
 }
  2.定义接口Runnable接口实现run()方法
public class Test02Runnable {
    public static void main(String[] args) {
        Thread t1= new Thread(new Prime());
        t1.start();
        Thread t2=new Thread(new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println("Runnable------>"+i);
                }
            }
        });
        t2.start();
        Runnable t3=new Prime();
        t3.run();
    }
}
class Prime implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("prime========>"+i);
        }
    }
}
  3.Callable接口    (FutureTask是Runnable接口的实现类 相当于实现Runnable接口,,而FutureTask(Callable<T>))这个方法
public class Test03 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask futureTask=new FutureTask(new Future());
        Thread t=new Thread(futureTask);
        t.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("main----->"+i);
        }
        System.out.println("t线程执行futureTask任务, 这任务结束后来,可以获得任务返回的结果: "+futureTask.get());
    }
}
class Future implements Callable{
    @Override
    public Object call() throws Exception {
        int num = new Random().nextInt();
        for (int i = 0; i < 100; i++) {
            System.out.println("callable---->"+i);
        }
       System.out.println("有时让线程执行某个操作, 得到一个操作结果: " + num);
        //返回线程操作结果
        return num;
    }
}
--------------------------------------------------------------------------------------
线程的常用操作:
   static int activeCount()  活动线程的数量  
             Thread.activeCount()
   static int enumerate(Thread[] tarray)  把活动线程复制到数组中
             Thread[] data=new Thread[Thread.activeCount()];
             Thread.enumerate(data);
   static Thread currentThread()  返回当前线程------>后续的方法操作都在此方法上调用
              Thread.currentThread() 
   ClassLoader getContextClassLoader()  返回线程上下文类加载器
          ClassLoader classLoader=Test03.class.getClassLoader();
          System.out.println(classLoader);
         //可以直接调用ClassLoader类的getSystemClassLoader()返回系统类加载器
          ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader();
          System.out.println(systemClassLoader);
        //返回当前线程上下文 的类加载器
          ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
          System.out.println(contextClassLoader);
   long getId()  返回线程的id     //java中创建一个线程后,系统会为这个线程分配一个唯一的id
            Thread.currentThread().getId()
   String getName()  返回线程名 
             Thread.currentThread().getName()
   void setName(String name)  设置线程名 
             t.setName()
   int getPriority()  返回线程优先级
            t.getPriority()
   void setPriority(int newPriority)  设置线程优先级
            t.setPriority(a)
       /*线程调度器在调度线程时有两种策略  
           分时调度, 每个线程执行固定的时长
           抢占式调度, 线程调度器随机选择某个线程执行
        Java采用抢占式调度策略
        在抢占式调度策略中, 理论上会优先调度优先级别高的线程
        java中每个线程都有一个优先级, 默认值为5, 可以重新设置优先级, 范围是1~10   (实际对优先级的执行不理想)
        在实际开发中,一般不设置线程优先级
       */
   void interrupt()  中断线程                    //使用此方法可以来设置run中条件,使其停止线程
           t.interrupt()
   boolean isInterrupted()  判断线程的中断状态    //默认值为false
           Thread.currentThread().isInterrupted()
   void join()  线程合并  可以在A线程中加入B线程, A线程就转为等待状态,等到加入的B线程执行完毕后,A线程再继续向下执行  
           t.join()
        /*
         线程的join()合并 可以被中断
         (等待线程)t.interrupt()  即可取消等待
         */
    void setDaemon(boolean on)  设置线程是否为守护线程守护线程不能独立执行, 当JVM中只有守护线程时, 守护线程会 自动结束 , JVM退出,垃圾回收器就是一个典型的守护线程
         t.setDaemon(true)
    static void sleep(long millis)  线程睡眠 ,单位是毫秒,可以被  interrupt()中断
         t.sleep(1000)
    TimeUnit.SECONDS.sleep(1);     //以秒为单位的sleep
    Thread.State getState()  返回线程状态
         t.getState()
        /*
     NEW  在创建
     RUNNABLE, 可运行状态, 表示t线程还没有结束
     TERMINATED, 终止状态,表示线程已经结束
     BLOCKED, 阻塞状态, 当前main线程与t线程两个线程并发执行,两个线程都调用了System.out对象的println方法打印字符串.println方法体是一个同步代码块, 在某一时刻只能 由一个线程调用. 当main线程先申请到System.out锁对象执行println方法, 这时如果t线程也想执行println方法需要先申请System.out锁对象, 这个锁对象现在被main线程持有,那么t线程就转为阻塞状态
        */
--------------------------------------------------------------------------------------
线程的生命周期:
   如图>
-------------------------------------------------------------------------------------
线程的安全问题:
  抽象内存模型
  线程安全出现条件:
    1.线程之间存在数据共享
    2.多个线程同时操作这个共享数据
  解决:
    1.通过ThreadLocal线程变量实现数据隔离,不让多个线程共享数据
    2.通过多个线程确实需要共享数据,进行线程同步
  线程同步技术:
    1.锁
    2.等待/通知
    3.volatile关键字
    4.final关键字
  特点:
    1.原子性
      原子是不可分割的,俩个含义:一是指在一个线程操作共享数据期间,其他线程看不到这个线程的中间结果,对于其他线程来说,要么这个线程还没开始操作,要么已经结束;二是线程操作共享数据期间,不允许其他线程参与进来
   public class Test01 {
    static int num=0;   //共享数据
     public static void main(String[] args) throws InterruptedException {
         Runnable r=new Runnable() {
             @Override
             public void run() {
                 for (int i = 0; i < 10000; i++) {
                     num++;
                 }
             }
         };
         Thread t1=new Thread(r,"t1");
         t1.start();
         Thread t2=new Thread(r,"  t2");
         t2.start();
         
         t1.join();
         t2.join();
//当一个线程需要读取一个变量时，它会先检查自己的工作内存是否有该变量的副本，如果有，就使用这个副本；如果没有，它就会从主内存中加载这个变量          //出现了数据不一致的情况, 称为线程安全问题
         System.out.println(num);
     }
   }
    2.可见性
       当一个线程修改了共享数据后,其他线程看不到修改的结果,还是读取了修改前的旧数据,即这个线程对共享数据的修改对于其他线程来说是不可见的
public class Test02 {
    public static void main(String[] args) throws InterruptedException {
        SubThread t=new SubThread();
        t.setFlag(true);
        t.start();
        Thread.sleep(1000);
        t.setFlag(false);
        System.out.println("main线程已经修改了t线程的flag标志,flag="+t.flag);
        ///运行程序后, t线程看不到main线程对它flag标记的修改, 即main线程对t线程flag标记的修改对t线程来说是 不可见的
    }
    static class SubThread extends Thread{
        private boolean flag;
        // private volatile boolean flag;      解决办法2
        // public synchronized boolean isFlag()   解决办法1
        public boolean isFlag(){
            return flag;
        }
        public void  setFlag(boolean flag){
            this.flag=flag;
        }

        @Override
        public void run() {
            System.out.println("线程启动时,flag: "+isFlag());
            //线程栈有自己的副本
            while (isFlag()){
            }
            System.out.println("线程在检测到flag标记为false时,什么循环结束");
        }
    }
}
    3.有序性
        CPU为了提高指令的执行效率,会优化指令的执行顺序,这种优化在多线程程序中可能导致数据不一致
特点:
   一个线程修改了共享数据后，其他线程仍然读取旧的数据的情况通常与Java内存模型中的缓存一致性有关。在多线程环境中，每个线程都有自己的工作内存（也称为局部内存或线程本地存储），用于缓存它所访问的变量的副本。这样做是为了提高性能，因为直接从主存中读取数据速度较慢。
   当一个线程修改了一个共享变量的值时，这个值首先被写入该线程的工作内存。在某个时间点，这些更改会通过一个过程称为“刷新”或“写回”，同步到主内存中。同样，当一个线程需要读取一个变量时，它会先检查自己的工作内存是否有该变量的副本，如果有，就使用这个副本；如果没有，它就会从主内存中加载这个变量。
   如果一个线程修改了共享变量但尚未将其刷新到主内存，那么其他线程在尝试读取该变量时，可能会看到旧的值，因为它们在自己的工作内存中有这个值的副本。这就导致了其他线程看不到修改后的共享数据。
```

![image-20240412193724391](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240412193724391.png)

![image-20240412201336479](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240412201336479.png)

```java
同步解决方法
1.volatile关键字
    特点:保证数据的可见性, 不能保证指令有序性和原子性,只能对字段进行修饰, 直接对主内存进行(而不是对线程栈的副本进行)
2.synchronized锁
    特点: 1)使用常量对象作为锁对象  (Object)且是同一个对象才能同步
          2)使用使用this当前匿名内部类对象作为锁对象
          3)使用当前类的字节码作为锁对象,也称为类锁,不建议
          4)使用字符串常量作为锁对象, 不建议
    概述:锁可以同步的数据的多少称为 锁的粒度. 锁对象同步的数据越多称锁的粒度越粗,  锁对象同步的数据越少称锁的粒度越细  用同一          个"LOCK"锁对象时, 可能造成不必要的等待, 即锁的粒度不是越粗越好
    同步方法:
      public void  m1(){
          synchronized ( this ){
             for (int i = 0; i < 100; i++) {
                 System.out.println("m1 --> " + i);
             }
          }
       }
      //同步实例方法, 默认锁对象是当前this对象
      public synchronized void m2(){
          for (int i = 0; i < 100; i++) {
              System.out.println("m2 ======> " + i);
          }
      }
    // 修饰静态方法则默认当前类的字节码为锁对象
      public static synchronized void m2(){
          for (int i = 0; i < 100; i++) {
              System.out.println("m2 ======> " + i);
          }
      }
  工作原理:
      1) 不管哪个线程想要操作共享数据前, 先申请锁对象, 锁就相当于共享数据的访问许可证
      2) 锁具有排他性, 在某一时刻最多只能被一个线程持有. 当A线程获得了锁对象, A线程可以操作共享数据,这时如果还有其他线程也想申请锁对象,那么 这些线程转为阻塞
      3) 持有锁的线程操作完共享数据后 会释放锁对象, 阻塞队列中的某个线程可能申请到锁
          Java中的锁分为 synchronized内置锁与Lock显示锁
3.java.util.concurrent包
     CopyOnWriteArrayList 线程安全的List集合
     CopyOnWriteArraySet 线程安全的Set集合
     ConcurrentSkipListSet 线程安全的Set集合, 可以实现排序
     ConcurrentHashMap  线程安全的Map集合
     ConcurrentSkipListMap 线程安全的Map, 可以根据键排序
  juc包中线程安全的集合并发效率更高, 如HashTable在某一时刻只能 由一个线程操作
  ConcurrentHashMap早期采用分段锁协议 , 默认分为 16 段锁, 理论上允许 16 个线程并发操作
  在JDK8中改为CAS, 允许更多的线程并发
--------------------------------------------------------------------------------------
脏读和死锁
   1.脏读就是在多线程程序中, 线程读取的数据不 是最准确的数据
    一是在某个线程修改了共享数据后, 其他线程读不到修改后的最新数据, 还是读取之前的旧数据(可见性)
    二是指在线程操作共享数据其他,  其他线程读取了这个线程的中间结果(破坏原子性)
解决方法:
   不仅修改数据时需要同步,  在读取数据时也需要同步 
  public class Test01Dirty {
    public static void main(String[] args) throws InterruptedException {
        SubThread t = new SubThread();
        t.setFlag(true);
        t.start();
        Thread.sleep(1000);
        t.setFlag(false);
        System.out.println("main线程已经修改了t线程的flag标志,flag=" + t.flag);
        //解决方法: setFlag(boolean flag)修改数据的方法与 isFlag()读取数据的方法都进行同步
    }
    static class SubThread extends Thread {
        private  boolean flag;
      //可以确保在一个线程修改共享变量时，其他线程不会同时访问该变量，直到锁被释放。
        public synchronized boolean isFlag() {
            return flag;
        }
        public  void setFlag(boolean flag) {
            this.flag = flag;
        }
        @Override
        public void run() {
            System.out.println("线程启动时,flag: " + isFlag());
            //线程栈有自己的副本
            while (isFlag()) {

            }
            System.out.println("线程在检测到flag标记为false时,循环结束");
        }
    }
}
--------------------------------------------------------------------
public class Test02Dirty {
    public static void main(String[] args) {
        MyValue myValue = new MyValue("zhangsan", "123");
        //开启一个线程修改数据
        new Thread(new Runnable() {
            @Override
            public void run() {
                myValue.set("lisi", "456");
            }
        }, "t1").start();
        //开启线程读取数据
        new Thread(new Runnable() {
            @Override
            public void run() {
                myValue.read();
            }
        }, "t2").start();
    }
    static class  MyValue{
        String name;
        String password;
        public MyValue(String name, String password) {
            this.name = name;
            this.password = password;
        }
        public synchronized void  set(String name, String password) {
            this.name = name;
            try {
                Thread.sleep(1000);     //通过睡眠模拟修改数据需要的时长
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            this.password = password;
        }
        public synchronized void read(){
            System.out.println("name = " + name);
            System.out.println( "password = " + password);
        }
    }
}
  2.死锁
    多线程程序中, 如果线程需要申请多个锁对象时, 因为申请锁对象的顺序不一致 , 可能会出现相互等待的情况, 称为死锁现象
解决方法:
    所有线程都按相同的顺序申请锁对象 
         public void run() {
            if ("a".equals(Thread.currentThread().getName())){
                synchronized ("lock1"){
                    System.out.println("a线程申请lock1,完成任务还需要申请lock2");
                    synchronized ("lock2"){
                        System.out.println("a线程同时获取lock1,lock2,结束");
                    }
                }
            }
            if ("b".equals(Thread.currentThread().getName())){
                synchronized ("lock2"){
                    System.out.println("b线程申请lock2,完成任务还需要申请lock1");
                    synchronized ("lock1"){
                        System.out.println("b线程同时获取lock2,lock1,结束");
                    }
                }
            }
        }
--------------------------------------------------------------------------------------    
通知和等待
   说明:
     1.wait()方法需要在同步代码块中由锁对象调用,否则可能会产生异常
     2.等待条件一般是while, 为了防止假唤醒, 
     3.wait()等待后线程会释放锁对象
     4.等待的线程需要被notify唤醒
未优化前:  俩个线程交替打印奇偶数
  public class Test01Wait {
    static int num = 0 ;
    //定义常量对象作为锁对象
    private static final  Object LOCK = new Object();
    public static void main(String[] args) {
        //开启线程打印偶数
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0 ; i < 100; i++) {
                    //当num不是偶数就等待,
                    synchronized ( LOCK ){
                        while ( num % 2 != 0 ){
                            try {
                                LOCK.wait();
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                    // 打印偶数,
                    System.out.println(Thread.currentThread().getName() + " ---- " + num++);
                    // 通知另外一个线程打印
                    synchronized ( LOCK ){
                        LOCK.notify();
                    }
                }
            }
        }).start();
        //开启线程打印奇数
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0 ; i < 100; i++) {
                    //当num不是奇数就等待,
                    synchronized ( LOCK ){
                        while ( num % 2 != 1 ){
                            try {
                                LOCK.wait();
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                    // 打印奇数,
                    System.out.println(Thread.currentThread().getName() + " ---- " + num++);
                    // 通知另外一个线程打印
                    synchronized ( LOCK) {
                        LOCK.notify();
                    }
                }
            }
        }).start();
    }
}
优化后:可以输入n个线程交替打印数字
public class Test06 {
    static int num = 0;
    private static final Object LOCK = new Object();
   static final int N=3;
    public static void main(String[] args) {
        for (int i = 0; i < N; i++) {
            final int reMid=i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    fun(reMid);
                }
            }).start();
        }
    }
    private static void fun(int x) {
        for (int i = 0; i < 100; i++) {
            synchronized (LOCK) {
                while (num % N != x) {
                    try {
                        LOCK.wait();  //线程等待后会释放锁对象
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                System.out.println(Thread.currentThread().getName() + " ---- " + num++);
                LOCK.notifyAll();
            }
        }
    }
}
```

![image-20240413210107145](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240413210107145.png)

![image-20240413212148641](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240413212148641.png)

```java
ThreadLocal线程
   作用:
     它的作用是实现线程之间数据的隔离
   创建:
       private static final  ThreadLocal<String> THREAD_LOCAL=new ThreadLocal<>();
   方法:
     set() 设置线程变量的值
     get() 返回线程变量的值
     remove() 删除线程变量
   实现:

public class Test03 {
    //把SimpleDateFormat对象保存在ThreadLocal线程变量中,实现对象的隔离
     private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");  //原先数据不隔离
    //在匿名内部类中重写 initialValue() 方法返回一个初始值
    private static final  ThreadLocal<SimpleDateFormat> THREAD_LOCAL = new ThreadLocal<>() {
        @Override
        protected SimpleDateFormat initialValue() {
            return  new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
        }
    };
    public static void main(String[] args) {
        for (int i = 0; i < 60; i++) {
            String text = "2024年05月16日 11:22:" + i;
            //开启 60 个线程
            new Thread(new Runnable() {
                @Override
                public void run() {
                    //在线程中使用sdf把text字符串解析为Date对象
                    try {
                        //从THREAD_LOCAL线程变量中调用get()方法返回SimpleDateFormat对象
                        Date date = THREAD_LOCAL.get().parse(text);
                        // Date date = sdf.parse(text);   原先数据不隔离
                        System.out.println( Thread.currentThread().getName() + " ---- " + date);
                    } catch (ParseException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}
  ThreadLocal通过为每个线程提供一个独立的变量副本来实现数据隔离，而内存泄漏是指这些变量副本如果没有被及时清理，可能会导致内存无法被回收。
  首先，来了解ThreadLocal是如何实现数据隔离的。ThreadLocal利用了一个名为ThreadLocalMap的内部结构来存储每个线程对应的变量副本。当一个线程首次访问ThreadLocal变量时，ThreadLocal会为该线程在ThreadLocalMap中创建一个初始值。随后这个线程对ThreadLocal的所有读/写操作都会在这个副本上进行，不会影响其他线程的副本，从而实现了数据隔离。当同一个线程再次访问ThreadLocal时，ThreadLocal会从Map中获取该线程对应的变量副本，而不是重新创建一个新的副本。
      
   其次，关于ThreadLocal与内存泄漏的关系。ThreadLocalMap中的每个条目都持有对ThreadLocal实例的强引用，如果这些条目没有被及时删除，即使线程执行完毕，这些强引用依然存在，导致相关联的对象不能被垃圾回收器回收，从而造成内存泄漏。为了避免内存泄漏，应该在适当的时候调用ThreadLocal的 remove()方法来清除线程对应的数据。

   最后，解决内存泄漏的方法是在使用完ThreadLocal后，显式调用 remove()方法来移除当前线程对应的ThreadLocal变量副本。这样可以确保ThreadLocalMap中的条目被及时清理，避免内存泄漏的发生。此外，将ThreadLocal变量定义为private static final可以确保其生命周期与应用程序相同，这样可以通过弱引用访问到ThreadLocalMap中的value值，并及时清除它。
```

## 线程练习

```java
银行取钱
public class Test03 {
    public static void main(String[] args) {
        //开户
        BankAccount bankAccount = new BankAccount();
        bankAccount.deposit(10000);

        //开户三个 BankUserThread 线程, 从同一个账户中取钱
        new BankUserThread("lisi", bankAccount).start();
        new BankUserThread("wife", bankAccount).start();
        new BankUserThread("bf", bankAccount).start();
    }
}

//定义银行用户类, 用户可以同时取钱, 可以简单的定义为线程类
class BankUserThread extends Thread{
    private  BankAccount bankAccount;

    //通过构造方法指定线程名(用户名), 与使用的账户
    public BankUserThread(String name, BankAccount bankAccount) {
        super(name);
        this.bankAccount = bankAccount;
    }

    @Override
    public void run() {
        synchronized (bankAccount) {        //使用银行账户作为锁对象
            System.out.println(Thread.currentThread().getName() + "查询余额:" + bankAccount.getBalance());
            bankAccount.withdraw(1000);
            System.out.println(Thread.currentThread().getName() + "取了1000后,余额:" + bankAccount.getBalance());
        }
    }
}

//定义银行账户类
class BankAccount{
    private int balance;

    //查询余额
    public int getBalance() {
        return balance;
    }

    //存钱
    public void deposit(int money) {
        this.balance += money;
    }

    //取钱
    public void withdraw(int money){
        balance -= money;
    }
}

```



```java
多窗口售票
public class Test01 {
    static int no;
    public static void main(String[] args) {
        Runnable r=new Runnable() {
            @Override
            public void run() {
                while (true){
                    synchronized (this){
                        if (no>100){
                            System.out.println(Thread.currentThread().getName()+" 票已售罄!");
                            return;
                        }
                            System.out.println(Thread.currentThread().getName()+" 出售第 "+(++no)+" 张票");

                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        };
        for (int i = 1; i <=5 ; i++) {
            new Thread(r,"窗口: "+i).start();
        }
    }
}

第二种方法
public class Test02 {
    public static void main(String[] args) {
        Window window=new Window();
        for (int i = 0; i < 5; i++) {
            new Thread(window,"窗口:"+i).start();
        }
    }

}
 class Window implements Runnable{
    Ticket ticket=new Ticket();
     public Ticket getTicket() {
         return ticket;
     }
     public void setTicket(Ticket ticket) {
         this.ticket = ticket;
     }
     @Override
     public void run() {
         while (true){
             synchronized (ticket){
                 if(!ticket.hasRemaining()){
                     System.out.println(Thread.currentThread().getName()+"票已告罄");
                     return;
                 }
                 System.out.println(Thread.currentThread().getName()+"出售第"+ticket.getTicket());
                 try {
                     Thread.sleep(20);
                 } catch (InterruptedException e) {
                     throw new RuntimeException(e);
                 }
             }
         }
     }
 }
class Ticket{
    int no;
   public boolean hasRemaining(){
       return no<100;
   }
    public String getTicket() {
        no++;
        return "ticket-"+no;
    }
    public Ticket() {
    }
}
```

```java
生产者与消费者设计模式
    概念:设计模式就是针对一般问题的解决方案, 这套方案已经被论证和认可, 可以反复使用
    生产者/消费者设计模式: 解决生产与消费之间的数据平衡问题
    说明:仓库不是无限大,有存储的最大容量
        在生产者向仓库中存储数据时, 先判断仓库是否已满, 当仓库满了,则生产者就等待
        在消费者从仓库中取数据时, 先判断仓库是否为空, 当仓库空了则消费者等待
        因为仓库满了导致生产者等待,  在消费者从仓库中取了数据, 通知等待的生产者继续生产
        因为仓库空了导致消费者等待, 在生产者向仓库中存储了数据后, 通知等待的消费者继续消费    
  仓库类
/**
 *  定义仓库类
 */
public class MyStorage {
    //仓库需要有一个存储数据的容器
    private List list = new ArrayList<>();
    //添加数据
    public synchronized void  add(Object data){         //同步实例方法,默认this对象为锁对象
        //当仓库满了就等待
        while (list.size() == 10 ){
            try {
                System.out.println(Thread.currentThread().getName() + " is  waiting...");
                this.wait();            //由this锁对象调用wait等待
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        list.add( data );
        System.out.println(Thread.currentThread().getName() + "添加数据:" + data + " 后,仓库容量为:" + list.size());
        //唤醒等待的消费者
        this.notifyAll();
    }
    //取数据
    public synchronized Object get(){           //同步实例方法
        //当仓库空了就等待
        while ( list.size() == 0 ){
            try {
                System.out.println(Thread.currentThread().getName() + " is  waiting...");
                this.wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        Object data = list.remove(0);
        System.out.println(Thread.currentThread().getName() + "取了数据:" + data + " 后,仓库容量为:" + list.size());
        //唤醒等待的生产者
        this.notifyAll();
        return data;
    }
 }
生产者类:
/**
 *  定义生产者类,
 *      可以由若干生产者同时生产数据, 就简单的把生产类定义为线程类
 */
public class Produer extends Thread{
    //有仓库
    private MyStorage myStorage;
    //通过构造方法指定线程名(生产者名), 使用哪个仓库
    public Produer(String name, MyStorage myStorage) {
        super(name);
        this.myStorage = myStorage;
    }
    @Override
    public void run() {
        //约定每个生产者向仓库中添加30次数据
        Random random = new Random();
        for (int i = 0; i < 30; i++) {
            myStorage.add(random.nextInt(200));
        }
    }
}
消费者类:
/**
 *  定义消费者线程类
 */
public class Consummer extends Thread{
    private MyStorage myStorage;

    //通过构造方法指定线程名(消费者名) , 使用哪个仓库
    public Consummer(String name, MyStorage myStorage) {
        super(name);
        this.myStorage = myStorage;
    }
    @Override
    public void run() {
        //约定每个消费者取30次数据
        for (int i = 0; i < 30; i++) {
            myStorage.get();
        }
    }
}
测试类:
/**
 *  具体操作
 */
public class Test {
    public static void main(String[] args) {
        //先创建仓库
        MyStorage myStorage = new MyStorage();
        //开启三个生产者线程,使用同一个仓库  每个生产者生成指定的次数(30次
        for (int i = 0; i < 3; i++) {
            new Produer("生产者:" + (i+1), myStorage).start();
        }
        //开启三个消费者线程使用同一个仓库  每个消费者消费指定的次数(30次
        for (int i = 0; i < 3; i++) {
            new Consummer("----消费者:" + (i+1),myStorage).start();
        }
    }
}
```

![image-20240415201916497](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240415201916497.png)

![image-20240415201936888](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240415201936888.png)

## 反射与注解

[^反射]: 在程序运行过程中, 根据内存中的类(字节码), 动态获得类信息, 创建类实例, 访问字段, 调用方法的技术
[^注解]: 程序中的一种特殊标记, 在编译,运行阶段可以根据注解的信息做额外的操作

![image-20240415202000702](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240415202000702.png)

```java
反射
 1.是获得(创建)Class对象, 有三种方式:
    Class c1 = String.class;
    Class c2 = "hello".getClass();
    Class c3 = Class.forName("java.lang.String");    // 系统会对Person类初始化, 执行Person类的静态代码块
 2.反射类的声明: public class String(){}
    2.1 调用Class对象的实例方法getModifiers()返回类的修饰符
        int mod = c1.getModifiers();           //方法返回值类型是int整数
        //调用java.lang.reflect包下面的Modifier修饰符类的静态方法toString( int )可以把整数转换为字符串修饰符
        System.out.println(Modifier.toString(mod));

    2.2 调用Class对象的实例方法getName()返回类名
        String name = c1.getName();            //返回全限定类名
        String simpleName = c1.getSimpleName();  //返回简单类名

    2.3 调用Class对象的实例方法getSuperclass()返回父类
        Class superclass = c1.getSuperclass();       //方法返回值是Class对象
        System.out.println(superclass.getName());

   2.4 调用Class对象的实例方法getInterfaces()返回接口
    Class[] interfaces = c1.getInterfaces();  //类可以实现多个接口,返回值是一个数组, 如果类没有实现接口,返回长度为0的数组
        for (Class anInterface : interfaces) {
            System.out.print(anInterface.getSimpleName() + "   ");
        }

  String的具体方法
      //private int a;
     3 用Class对象的实例方法getFields()反射类中public修饰的公共字段,包括从父类继承的公共字段
         claxx.getDeclaredFields()返回本类中定义的任意权限的字段, 不包括从父类继承的
        Field[] declaredField = c1.getDeclaredFields();  //字段对象
        for (Field field : declaredField) {
            System.out.print(Modifier.toString(field.getModifiers()) + " ");  //字段修饰符
            System.out.print(field.getType().getSimpleName() + " ");   //获得字段类型   int  char[]
            System.out.println(field.getName());                      //字段名
        }
     //public static  void  sum(int a,int b)
     4 调用Class对象的实例方法getDeclaredMethods() 反射本类中定义的任意权限的成员方法
        claxx.getMethods() 返回public修饰的公共方法,包括从父类继承的公共方法
        Method[] methods = c1.getMethods();              //方法对象
        for (Method method : methods) {
            System.out.print(Modifier.toString(method.getModifiers()) + " ");       //方法修饰符
            System.out.print(method.getReturnType().getSimpleName() + " ");         //方法返回值类型
            System.out.print(method.getName() + " (");                              //方法名
            //method.getParameters()返回方法参数列表,包括参数类型与参数名,参数名可以随便命名
            Class<?>[] parameterTypes = method.getParameterTypes();                //方法参数列表
             for (int i = 0; i < parameterTypes.length; i++) {
                System.out.print(parameterTypes[i].getSimpleName());
               if (i < parameterTypes.length - 1) {
                System.out.print(",");
                   }
                 }
              System.out.println(")");
           }
       //public Student(int a,String s)
      5 反射类中的构造方法    构造方法没有返回值
        Constructor[] constructors = c1.getConstructors();
        for (Constructor constructor : constructors) {
            System.out.print(Modifier.toString(constructor.getModifiers()) + " ");    //构造方法修饰符
            System.out.print(constructor.getName() + "(");                           //构造方法名
            Class[] parameterTypes = constructor.getParameterTypes();            //构造方法参数列表
             for (int i = 0; i < parameterTypes.length; i++) {
                System.out.print(parameterTypes[i].getSimpleName());
               if (i < parameterTypes.length - 1) {
                System.out.print(",");
                   }
             }
            System.out.println(")");
        }
----------------------------------------------------------------------------
反射创建类的实例:
   1.创建对象
        Class<Person> c=Person.class; 
   2.构造方法
    2.1 无参构造方法
        Person p1=c.newInstance();     //p1就是无参构造方法构造的对象
    2.2 有参构造方法
         Constructor<Person> constructor=c.getConstructor(String.class,int.class);
        Person p2=constructor.newInstance("lisi",18);
   3.反射访问字段
       Field name = c.getField("name");        //public的name这个属性 
       Field age = c.getDeclaredField("age");   //任意权限的age这个属性
             //如果是拿到field[] 这个方法集合,那么遍历它,就是遍历每一个属性
       name.set(p1,"张小三");                  //设置p1对象的name
       age.setAccessible(true);  //age是private的  Java中没有严格意义上的封装, 私有成员可以通过反射访问到
       age.set(p1, 18);
       name.get(p1)           //返回p1对象的name值
       age.get(p2)             //返回p2对象的age值
  4.反射访问成员方法
      Method set = c.getMethod("set", String.class, int.class);   //set(String,int)方法   创建set对象
      Method setAge = c.getMethod("setAge", int.class);           //setAge(int)方法
      Method getAge = c.getMethod("getAge");                     //getAge()方法
      //调用Method对象的 invoke( 实例名, 实参列表 ) 可以执行这个方法
      set.invoke(p1,"张三",18);
      setAge.invoke(p1, 32);     
      Object obj=getAge.invoke(p2);
//如果方法内有变量 a
      system.out.println(setxxx.a);
  5.反射访问注解类
      MyAnnotation classAnnotation = c.getAnnotation(MyAnnotation.class);
       classAnnotation.name
       classAnnotation.value
  6.反射访问注解方法
         Method method = c.getMethod("sm");
        MyAnnotation methodAnnotation = method.getAnnotation(MyAnnotation.class);
         获取属性:  String value = methodAnnotation.value();
         执行方法    method.invoke(sm)         //非静态方法的调用
                    method.invoke(null);        //静态方法调用时,在对象名位置传递null
```

```java
注解
例子:  
   @Override  告诉编译器, 检查方法覆盖是否符合规则
   @WebServlet  
   @Deprecated 标记这个成员已弃用, 不建议再使用它了
   @FunctionalInterface 把接口声明为函数式接口, 这是在JDK8中新增的, 当接口只需要重写一个抽象方法时可以声明为函数式接口,这是专门为Lambda表达式准备的
   @SupressWarnings 可以抑制警告信息
自定义注解:
  1 使用  @interface 定义注解, 可以把注解看作是一种特殊的接口
  2 在定义注解时, 通过使用@Target注解指定当前注解可以修饰哪些成员
     说明:   value属性, 它的数据类型是 ElementType[] 数组
     格式:   @Target( value =  {ElementType.TYPE, ElementType.METHOD}) 
     解释:
      TYPE: 用于描述类、接口（包括注解类型）或枚举声明。
      FIELD: 用于字段（成员变量）
      METHOD: 用于方法
      PARAMETER: 用于方法参数
      CONSTRUCTOR: 用于构造函数。
      LOCAL_VARIABLE: 用于局部变量
      ANNOTATION_TYPE: 用于注解类型声明。
      PACKAGE: 用于包声明
      MODULE: 用于模块声明。
      RECORD_COMPONENT: 用于记录组件的声明。
      cLASS: 用于类声明
 3 在定义注解时, 通常使用@Retention注解指定当前注解保留的时长
     说明:   value数据类型是RetentionPolicy
     格式:   @Retention(  RetentionPolicy.RUNTIME)
     解释:
      SOURCE:编译期      @Deprecated 和 @SuppressWarnings。
      CLASS:加载期       @Entity（JPA）或 @Inject（CDI）
      RUNTIME:运行期      @Autowired（Spring框架）
 4 在定义注解时, 可以没有属性, 也可以在注解中定义属性, 格式为:  数据类型 属性名 () [default 默认值]
      String name() default "bjpowernode";
      String value();
5 使用注解格式:  @注解名( 属性名=属性值, 属性名=属性值 )
      如果注解没有属性, 小括弧不能省略
      如果属性有默认值则可以不给属性赋值
      如果注解只有一个属性时, 属性名可以省略
------------------------------>
@Target( value =  {ElementType.TYPE, ElementType.METHOD})    
@Retention(  RetentionPolicy.RUNTIME)  
public @interface MyAnnotation {
    String name() default "bjpowernode";
    String value();
}
--------------------------------->
@MyAnnotation( name = "feifei",  value = "controller")
public class MyClass {

    @MyAnnotation( value = "XYZ")
    public static void sm(){
        System.out.println("MyClass类中的静态方法");
    }
}
```

```java
通过反射获得注解的信息,根据注解信息做进一步操作
 public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
            // 反射类的注解
            //getAnnotation( Class ) 返回指定类型的注解
        Class<MyClass> c = MyClass.class;
        MyAnnotation classAnnotation = c.getAnnotation(MyAnnotation.class);
        if ( classAnnotation != null ){
            System.out.println( classAnnotation.value());
            System.out.println(classAnnotation.name());
        }

        //反射方法的注解, 先反射方法
        Method method = c.getMethod("sm");
        //调用Method对象的getAnnotation( Class ) 方法返回方法的注解
        MyAnnotation methodAnnotation = method.getAnnotation(MyAnnotation.class);
        if ( methodAnnotation != null) {
            String value = methodAnnotation.value();
            if ("XYZ".equals( value)){
                //method.invoke(sm)         //非静态方法的调用
                method.invoke(null);        //静态方法调用时,在对象名位置传递null
            }
        }
    }
```

# 数据库技术

## SQL语言

1)DDL:DataBase  Defined  Language,数据库定义语言/数据库维护命令

2)DML:Data Modify Language，      数据行维护命令（insert/update/delete）

3)DQL:Data Query  Language,       数据行查询命令

```mysql
DDL
 1 通知MySql服务器管理【数据库】
         create database student_1;    
         show databases;
         drop database student_1;
 2 通知MySql服务器管理【数据库中表文件】
	      use xxx;    #进入xxx的表
          show tables;
          create table student_1(
              id  int,
             name varchar(5),       #注意是逗号
             sex varchar(1)
              );
         drop table student_1;  
  3 通知MySql服务器管理【数据库中表文标题行】
	     show create table student_1;
         alter table student_1 add age int;
         alter table student_1 drop age;
  DML
   作用: 要求MySql服务器对表文件中数据行进行维护
   1.insert
      标准命令格式:  insert into 表(字段名1,字段名2,字段名3) value(值1,'值2',值3);
      简化命令格式: insert into 表   values(值1,'值2',值3);
      批处理添加命令格式： insert into 表 value(值1,'值2',值3),(值1,'值2',值3),(值1,'值2',值3);
   2.update
       update 表  set 字段1=新值,字段2=新值2 where 条件;
   3.delete
       delete from 表  where 判断条件;
 ------------  ------------  ------------  ------------  ------------  ------------  ------------      
 1.表文件备份：
         1） 格式：   create table 新表 select * from 旧表
 2.数据行备份:
         1） 格式:    insert into 表1   select *  from 表2
	    2） 作用：   通知MySql服务器将表2中所有的数据行复制到表1
	    3） 要求：
	          表1中字段名称与表2中字段名称可以不相同
		      表1中字段个数必须与表2中字段个数相同
		      表1中字段类型必须与表2中字段类型相同(长度无要求)
		      表1中字段排列顺序必须与表2中字段排列顺序相同
		      表1必须是数据库已经存在的表
 ------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------ 
  DQL
  1.单表查询命令:
      执行顺序: from > where >group by  >having >select>order by 
       from: 定位查询的表文件
	   where:负责遍历FROM提供临时表每一行数据，每次遍历时只能操作临时表一行数据
	      1)关系表达式   <  <=  >  >=
	      2)逻辑表达式   and  or
	      3)特殊表达式  in()          包含多个满足条件 or的关系
                        not in()      不包此括号内的条件  and的关系
                        is  null      字段为null的,如果 age=null,null表示不清晰的值，null与null之间无法判断是否相等
                        between...and...  
                        like          模糊查询  like '%s':以s结尾  's%':以s开头 
	   group by: 按照数据行特征进行分组
	   having  : 将不满足条件分组撤销，与group by联合使用
	   select  : 从定位的数据行抓取信息
	   order by xx [asc desc]: 根据数据行特征对数据行排序  后面加arc则从大到小
	   聚合函数: 对临时表中字段下所有的数据进行统计，运行后返回一个统计结果
	                  1) min(字段)： 返回字段下所有数据中最小的值  
	                  2) max(字段)：返回字段下所有数据中最大值
	                  3) avg(字段)： 返回字段下的平均值
	                  4) sum(字段)： 返回字段下所有数据相加之和
	                  5) count(字段)：返回字段下内容不为null的数据个数
	                  6) count(*):   返回表文件总行数
#问题：      where能不能调用聚合函数 ：不能
#            where[逐行遍历]数据行，每次【得到一个数据行】与定位条件进行判断
#            聚合函数在工作时，需要得到指定字段下所有的数据进行统计
2.多表查询命令
    笛卡尔积
    内连接:      from  A  join  B   on  合法数据行定位条件
    外连接:     当连接查询时,需要帮助的表和不需要帮助的表连接时,需要帮助的表部分内容不会显示
               区别1：【需要帮助的表】  【不需要帮助的表】  是否为null
               区别2：外连接过滤方案对JOIN生成的临时表进行两轮遍历
               第一轮遍历，执行与内连接过滤方案完全一致     第二轮遍历，来自于【需要帮助的表】并且与【不需要帮助的表】的所有数据行都无法匹配成功数据行将这样的数据行带入到合法隶属关系表，缺失信息全都设置为null.
                from  【需要帮助的表】left join   【不需要帮助的表】  on  xxx
                from  【不需要帮助的表】 right join【需要帮助的表】 on   xxx 
     多表连接:  from  [表1] join [表2] join [表3] on xxx and xxx
                from  [表1] left join on  xxx  left join xxx
3.子查询命令
    where: 一次操作一行
    having:一次操作一个临时表
    select: 一次抓取一列   在SELECT将要操作临时表任意添加新列，供SELECT抓取使用
           select  '给默认值' as '新字段名'  ---->自动调用 update  
    from 可以生成一个临时表来提供这个字段
            子查询帮助from时，提供一个临时表，这个临时表必须手动指定别名。
            子查询帮助from时，提供一个临时表，表中字段名称不能以函数名来命名
4.联合查询命令
    union
 ------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------ 
 其他
 1.case..end:
     1) case..end在Select执行之前执行
     2）【逐行遍历】每一个数据行，并给出对应解释
    例子:                select  ename,sal,
                             (case 
                             when  sal =(select max(sal)  from emp) then '第一名'
                             when  sal=( select distinct sal     from emp order by sal desc limit 1,1) then'第二名'
                         else  '第三名'
                     end) as '名次'
                        from emp
                        where sal  in (
                                 select sal  from 
                                 (select distinct sal from  emp   order by sal desc  limit 0,3) as t ) 
                        order by  sal desc
 2.ifnull(xx,yy)
     如果xx不为null,则输出xx  如果xx为null,则输出yy
     
     
```

```mysql
五种常见题型
in,all,any,some四种运算符之后出现查询语句，不能有limit命令    
  解决 套娃
     where sal  in(  select sal 
       from (select distinct sal  from emp  order by sal desc limit 0,5) as t 
                                                      )
1.排名题型
       第一步: 获得排名时依赖数据   [返回几个值]
            [去除重复数据]   [排序]  [截取]
       第二步: 使用依赖数据对业务表数据行排查
2.列转行
   将原始表原本存储在同一列中数据变为同一行展示
   如果发现查询结果中，某个字段多次出现
#        [员工姓名]        [员工直属领导姓名]
#          emp.ename         emp.ename
即学过1号课程又学过2号课所有学生的姓名。
select S.sno   ,   S.sname       ,   sc1.scgrade       ,  sc2.scgrade
            from  sc  as sc1 # sc1提供学员【1号课程成绩】
                    join
                   sc  as sc2 # sc2提供学员【2号课程成绩】
                     join
                    s
           on  sc1.sno = sc2.sno and sc1.cno=1 and sc2.cno=2 and sc1.sno =S.sno
                      order by s.sno asc
3.交集
      第一步：获得集合A
      第二步:  获得集合B
      第三步：A JOIN B
      即学过1号课程又学过2号课所有学生的姓名
       select s.sno,s.sname,t1.scgrade,t2.scgrade
              from
                      (select  sno,scgrade   from  SC  where  cno=1) as t1        
               join
                       (select  sno,scgrade   from  SC  where  cno=2) as t2
              join
                         S
                        on  t1.sno = t2.sno and  t2.sno=s.sno
                        order by  s.sno
4.补集
     需求: 获得集合A
     第一步: 获得集合B
     第二步: 从集合S剥离掉集合B，剩下就是集合A
     找出没选过“黎明”老师的所有学生姓名。
       select sno
               from SC
               where cno in (select cno   from C  where cteacher='黎明')
5.并集
     第一步：将原始表拆分为若干个【字段结构一致临时表】
     第二步: 将临时表数据行通过union堆砌一起。
     select sname, 'java' as course,java_Score AS SCORE  from  student
             union
      select sname, 'SQL' as course ,sql_Score  from  student
        order by sname desc
 
```

## 存储引擎

[^特点]: MySql服务器对表文件采用管理方案

```mysql
1) 查看当前MySql服务器支持的存储引擎
                show engines;
2)查看表文件依赖的存储引擎
               show  create table student #InnoDB
3)修改表文件依赖的存储引擎
               alter table student  engine=MyISAM
4) 修改MySql服务器默认采用存储引擎
          my.ini文件：C:\Program Files (x86)\MySQL\MySQL Server 5.5\my.ini
                      84  default-storage-engine=INNODB
                      
InnoDB  与  MyIsam 区别:
         InnoDB:
         1)每当MySql服务器需要对InnoDb管理的表文件内容进行修改(insert/update/delete),InnodB出面阻拦 
         2)InnoDB首先要求MySql服务器对当前表生成备份表(create table 备份表 select * from 原始表) 
         3)InnoDB 要求MySql服务器在备份表进行操作,最大限度保障原始表数据安全性,效率慢
         
         MyIsam: 提高表文件效率
           1)MyIsam不支持备份表操作,运行MySql服务器直接在原始表操作
           2 )多文件存储,压缩搜索范围,提高效率
             xx.frm    字段信息
             xx.myd   数据行
             xx.myi     索引  
```

## 视图

```mysql
介绍：MySql服务器提供一种管理方案。增加查询语句的复用性;分配开发人员对于表中字段的使用权  #权限
     1.生成视图对象
     create  view xx as select empno,ename,job from emp
     2.查询视图
     select * from xx   (将得到 empno,ename,job 三个字段)
     3.增加数据
      insert into xx(empno,ename,job)  value(99999,'xxx','xxxx')   只能增加这三个字段

```

## 约束

```mysql
自动创建索引
  1.主键约束   primary key
  2.非空        not null
  3.唯一        unique
  4.外键        alter table  emp   add constraint  dept_emp_fk  foreign key(deptno)
                  references dept(deptNo)
```

## 索引

```mysql
 1.询问表文件中哪些字段关联了索引
            show  index from emp
 2.手动建立索引
           create  index  sal_index on emp(sal )   #索引自动排序
 3.删除索引
           drop index sal_index on emp
 mysql服务器在索引获得定位的方式   BTREE(查找二叉树的一种优化,不然每次删除,添加数据都要旋转二叉树,将值改为区间)
 
 执行计划   explain
    explain select * from emp where sal<1000
   type类型
    1)作用: 对查询语句评价,比如是否得到索引的帮助,索引提供何种帮助
    2)分类  all<index<range<ref<const
   
    all:全表扫描,这样查询语句势必在数据行增加情况下,大幅度降低执行效率
    index:定位时并没有使用索引定位,但是抓取数据时并不是从表中字段抓取,而是从字段关联索引中抓取对于查询语句执行效率有一定帮助
            xp[索引] where xp[索引]<a    
    range:得到索引帮助,索引提供区间范围   
       当行数大于1/3 时 那么就摒弃range  当数据内容种类过于单一时,不适合建立索引
             where xp[索引]<a; 
   ref: 定位数据行,得到索引帮助,索引提供[准确位置]  
             where xp[索引/非索引]=a;
   const: 定位数据行得到索引帮助,并且提供帮助索引是 [聚簇索引]
          [聚簇索引] vs [非聚簇索引]
   
      非聚簇索引：关联的字段是非主键字段。
                        索引存储【字段内容---所在数据行位置】
                         在提供帮助时，提供【数据行位置】。
                         where根据位置到表文件进行定位，这种行为被称为回表操作

      聚簇索引： 关联的字段是主键字段。
                       索引存储【主键值---数据行内容（ename:smith,job:clerk,sal:800.....）】
                       在提供帮助时，直接将对应数据行交给where
                       
 总结:index和range都是索引查找的条件,如果查找行数小于1/3则为range 
         如果大于1/3则看字段名,字段名为索引则为index,否则为all
```

## JDBC

```java
一。jar包
     1.".jar"结尾的压缩文件
     2.jar包存放.class文件    
     3.便于class文件复用
   1)jar包的生成:
         创建类/接口-->file-->Project Structure-->Artifacts-->添加jar取名,将要生成的jar包的类拖入
   2)jar包的导入:
         将jar包的压缩包导入项目,右键项目-->add as library -->Bulid-->Bulid Artifacts-->(jar包)Bulid
 二。JDBC介绍
     1.JDBC是Java体系唯一的一种用于进行SQL语句推送的通信协议
     2.SUN公司对于JDBC规范只提供了接口没有提供实现类，接口存放 jdk.jar中java.sql包
     3.JDBC规范的实现类由各个数据库服务器厂商来提供
     4.MySql服务器厂商对JDBC接口实现类存放mysql-conector-java.jar
三。JDBC规范下常见的接口
    1.java.sql.Driver接口：许可证协议规则，由各个数据库厂商负责提供实现。当应用程序得到了
                           某个数据库厂商提供Driver接口实现类时就等同于得到一个许可证，这个
			   许可证将允许这个应用程序去建立通道指向对应的数据库服务器

   2.java.sql.DriverManager类:持有数据库厂商提供Driver类情况下完成通信通道的建立。
                              DriverManager就是【隧道挖掘工】

   3.java.sql.Connection接口：指定维护管理通信通道规则，Connection对象就是【隧道维护管理人员】

   4.java.sql.PreparedStatement接口:指定了在通信通道上进行运输规则.PreparedStatement对象【快递小哥】 
四。JDBC规范下--通信规则
  1.将数据库服务器厂商提供的jar包引入到项目
  2.创建Driver对象并交给DriverMananger管理
  3.DriverManager驱动Driver对象打通通道。建好通道交给Connection对象管理
  4.由Connection对象负责提供一个PreparedStatement对象
  5.由PreparedStatement对象将sql语句从客户端推送到服务端，交给MySql服务器执行
    然后由PreparedStatement对象将MySql服务器执行结果带回到客户端
  6.卸磨杀驴，（1.kill PreparedStatement 2.Connection con ）
五.java代码
       public static void main(String[] args) throws SQLException {
        int result = 0;
        String url = "jdbc:mysql://localhost:3306/test";
        String userName = "root";
        String password = "123";
        String sql1 = "insert into dept value(80,'物流部','武汉')";
        String sql2="update dept set dname=?,loc=? where deptno=?";    //占位符
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;   //查询返回的结果

        try {
            DriverManager.registerDriver(new Driver());
            con = DriverManager.getConnection(url, userName, password);
            ps = con.prepareStatement(sql);
               ps.setString(1, dname);  //设置占位符
               ps.setString(2, loc);
               ps.setInt(3,deptno);
             result = ps.executeUpdate();  //插入,删除和更新 返回的是操作的行数(正数)
             rs = ps.executeQuery();     //查询返回的是ResultSet对象
                while (rs.next()) {
                System.out.println(rs.getInt(1) + " " + rs.getString(2) + " " + rs.getString(3));
                                    // getString("deptno")  隐式类型转换
                  }
        } finally {
            if (ps != null) {
                ps.close();
            }
            if (con != null) {
                con.close();
            }
        }
        if (result > 0) {
            System.out.println("创建成功   ");
        } else {
            System.out.println("创建失败,请检查");
        }
    }
```

## 事务

```java
一。事务管理对象(Transacion)
 
    1.InnoDB：【强调表文件数据安全性】。每当MySql服务器
              要求操作InnoDB管理的表文件数据行时，InnoDB要求MySql服务器首先对当前表文件生成备份表
              CREATE TABLE 备份表 SELECT * FROM 原始表
              然后InnoDB要求MySql服务器对备份表数据行进行操作
              insert  into 备份表
              update  备份表
              delete from 备份表

   2.事务管理对象介绍
      每当一个客户端与MySql服务器建立通信通道时候，MySql服务器负责在通道尽头
      生成一个事务管理对象。事务对象与Connetion一一对应。   // 同一个通道进行相同的sql事务管理
       管理资源：与之对应的通道推送而来的DML语句所产生的备份表 

    3.对备份表操作
       1）提交操作：commit, 将【备份表内容替换到原始表】----如果备份表操作结果与预期一致
       2）回滚操作: rollback,将【备份表】就地销毁
 
     4.事务对象由谁管理                              -----------》备份表1
         默认情况下：  【mySql服务器】----->事务管理对象
                                                    ----------》备份表2
                                                               -----------》备份表1
         手动设置：     【通信通道Connection】----->事务管理对象                                                                                                ----------》备份表2
      5.手动管理事务对象
 
           start transaction; #开启事务管理；向MySql服务器讨要当前通道尽头的事务对象管理权
                   con.setAutoCommit(false);
           delete from emp;   # 1.生成emp.bak      2. delete from emp.bak  3.emp.bak-->T(事务管理对象)
           delete from dept;  # 1.生成dept.bak     3. delete from dept.bak 3.dept.bak-->T(事务管理对象)
           commit;            # T将emp.bak和dept.bak内容【替换/覆盖】到原始表
           rollback;          # T删除emp.bak和dept.bak
 
     6.事务对象存在意义：
        在服务失败时，可以将用户损失降低为0，确保在本次失败服务中，不会修改用户任何数据
 
      7.事务对象【使用原则】----ACID
       1)【使用原则】---原子性
          【问题】：哪些备份表可以交给同一个事务对象管理
          【答案】: 同一个业务下产生备份，应该交给同一个事务对象管理
 
          【错误】:
                   业务1:裁员广进
                         delete from emp where deptno=?
                         delete from dept where deptno=?
                    业务2：新生登记
                         insert into student  values();
 
                    start transaction;
                      delete from emp where deptno=? # ok
                      delete from dept where deptno=? #ok
                      insert into student  values();# #问题
                     rollback;
             【正确】:
                       start transaction;
                      delete from emp where deptno=? # ok
                      delete from dept where deptno=? #ok
                       commit;

                      start transaction;
                        insert into student  values();# #问题
                      rollback;
           2)【使用原则】---一致性
              【问题】：为什么【同一个业务下备份表要交给同一个事务对象管理】
              【答案】: 在一个业务中只要有一个分支任务是失败，整个业务应该判定为失败。
                       此时事务对象【必须进行整体回滚】
              【错误】
                       start transaction;
                          delete from dept where deptno=? #ok
                          delete from emp 【whre】 deptno=? # error
                       commit;
 
                       [脏数据行]
 
              【正确】:
                         start transaction;
                             delete from emp where deptno=? # ok
                            delete from dept 【whre】 deptno=? #error
                         rollback;
               3)【使用原则】---持久性 在commit之后没有机会回滚
 
               4)【使用原则】---隔离性
                  1)读已提交
                       只允许事务读取以提交的数据,如果数据未提交则一直等待
                  2)读未提交
                       运行读取未提交的数据,导致脏读,可能数据提交失败
                  3)可重复读
                       在事务开始前将表中数据存储在内存的缓存区内,无论事务是否完成,都读缓存区内的数据
                   4)串行读
                       防止脏读,幻读和不可重复读
                           1)脏读  读取未提交的数据
                           2)幻读  其他事务插入或删除行导致的
                           3)不可重复读 其他事务更新行导致的
      8.何时应该使用Connection管理Transaction
        例子： select * from emp   查询语句不会生成备份表
 
        例子: 业务只有一个DML语句              不需要手动事务对象管理，mySql管理事务对象即可
               delete from emp [wher] deptno=?
 
         只有在当前业务中【包含了两条以上的DML语句】，才需要手动进行事务对象
```

## 封装

```java
 1)基于流程的封装
       dao包  -->完整的开发步骤
 2)基于特征的封装
       Entity工具类(实体类)
 3)基于功能的封装
       util包-->有些命令行【书写长度过长】或者有些方法调用是需要实参过多，增加开发人员这个功能难度。
 4)基于服务的封装
       实际开发过程中，用户的需求中往往包含多个分支任务 将某个服务中包含的所有分支任务封装到一个方法中
	 降低再次提供服务的难度
```

![image-20240423081457077](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240423081457077.png)

# web前端

![image-20240423094457509](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240423094457509.png)

## HTML/CSS

```html
1.POST和GET的区别
   浏览器的请求发式共有其中,其中java只考虑俩中 get和post
    1）如果浏览器采用GET方式，此时GET方式要求浏览器在请求行中存放的请求参数的数量不能超过4K,POST则无要求
    2）对于以GET方式得到资源。此时GET方式要求浏览器将【请求地址】与【返回资源】形成一个键值对保存在浏览器的内存中,方便多次请求,POST则禁止浏览器对返回资源进行缓存
    3）如果浏览器采用GET方式，此时GET方式要求浏览器必须在地址栏中展示推送的请求参数,POST方式禁止浏览器在地址栏中展示请求参数信息
    4）如果浏览器采用GET方式，此时GET方式要求浏览器必须将请求参数保存在[请求行],POST方式要求浏览器必须将请求参数写入到[请求体](用户看不见)

2.请求参数
  1) 超链接标签可以为浏览器提供请求参数  
		     <a href="请求地址?请求参数名1=值1&请求参数名2=值2">提示信息</a>
  2) 表单域标签(表单标签则不可以)

3.常见命令格式
  1）超链接标签命令
	  格式：     <a href="地址">提示信息</a>
  2）表单标签命令
	  格式：      <form action="地址">
		             <input type='submit' value='提示信息'/>
		         </form>
  3)表单域
     3.1)下拉列表标签
       <select name="home">
          <option value="sx">山西</option>
          <option value="sd">山东</option>
      </select>    
     3.2)多文本
       <textarea name="xx"></textarea> 多行文本框标签
     3.3)表单输入
       <input type="xxx" name="username"/>
		  text:文本文件
           password:密码
           file:文件
           radio:单选框,默认值为选中的第一个(在同一个name中则标记为同一个单选类型)
           checkbox:单选框,默认值为on选择的第一个(在同一个name中则标记为同一个单选类型) dom.checked-->true/false
           submit:提交,进入form的地址
           reset:重置
           button:按钮 与javascript一起使用
  4)居中
  <center></center>
  5)设置字体,颜色大小
    <font style="color: red;font-size:40px" ></font>
  6)表格,设置边框和位置
    <table border="2px" align="center">
        <tr>
           <td></td>
            <td></td>
        </tr>
  </table>
 7)列表
   <ol>
       <li></li>   <!--1,2,3-->
  </ol>
 <ul>
       <li></li>   <!--符号列表-->
  </ul>
  8)屏幕分割
  <frameset cols="15%,65%,20%">  <!--rows/cols-->
    <frame src="/t/index_1.html">
    <frame src="/t/index_2.html">
    <frame src="/t/index_3.html">
</frameset>
9)css设置字体样式   <!--样式优先级:   属性style  >  id  >  class  >  标签选择器( 子 > 父)    -->
   <style type="text/css">
        li{       标签 父
            
        }
        ul li{    标签 子
           
        }
       .xx{        class  
           
       }
       #rr{        id
           
       }
    </style>
10)display="none"  隐藏
   display="block" 显示 
11) span:设置table宽度
12)disabled  -->true  不可用
```



## JavaScript

![image-20240425153511367](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240425153511367.png)

```html
基础:
  遇见的问题:
      1.js 中字符串转数字  str*1
  window.alert()  窗口对象显示内容
  script    此标签可以写在任何地方
  <script type="text/javascript" src="/t/js/one.js">  //src的内容会覆盖标签内的内容
    window.alert("我是本地人");
</script>
弱类型和强类型
   弱类型表示对数据类型的忽略,如参数传递任何数据类型(javascript)
   强类型表示对数据类型的严格要求,c/c++ 和 java 是强类型,为了面对对象的内容,于是才诞生了重载

<!--    变量和函数对象都自动给了window对象   -->
1.变量
   1)声明变量
   2)变量赋值
   3)使用变量
  let 和 var 定义变量  (var定义变量可以省略)
2. 数据类型分类      typeof-->查看变量的类型
         基本数据类型(number<NaN{数据损坏},Infinity{无穷}>,string,boolean)
         引用数据类型(function,object<null,集合>)
         undefined
3.集合
      定义:
          list=[];
          list1=new Array();
       赋值:
           list[0]=xxx;
           list.push(true,new Date(),xx)
4.函数
      创建:
         1).标准函数对象方式
             function 函数对象名(){}
         2).命令行式样的函数对象声明
             var 函数对象名 =function(){}
             
       调用:
          window.fun()
             
       arguments(参数数组):
          在每一个函数调用中,传递的参数可以是任何数据类型,任何长度,都存储在arguments这个集合中,默认值为undefined
          在函数体中的参数则会在arguments中取
          在接收到不同的参数时,可通过arguments[i] 进行数据的操作
             
        面试题内容:
          浏览器对于<script>按照自上而下形式编译两次
          第一次：将所有【标准形式声明函数对象】进行创建
          第二次：编译执行所有的【命令行】
5.构造函数
       [普通功能函数]---------------对象.fun1(),通过return返回处理结果
       [自定义构造函数]-------------new fun1(),此时return失效，返回一个object类型对象
        普通方法【this】:指向当前调用这个方法的实例对象
        构造方法【this】:指向本次创建的实例对象
        function Student(p1,p2){
            this.sid=p1;
            this.sname=p2;
        }
        var stu=new Student(10,"smith")
        stu是实例对象   Student是函数对象
6.JSON格式
     第一件事：声明一个类文件描述特征
       public class Dept{
            public int deptNo;
            public String dname;
            public String loc;
      }
     第二件事:将类文件交给JVM，让JVM依据类文件创建出对应实例对象
             Dept dept=   new Dept();
             
     JavaScript是弱类型编程语言，对于数据类型及其反感。
     JavaScript建议前端工程师直接向JavaScript编译器申请需要对象----JSON对象描述格式
      var stu={"deptNo":15,"dname":"物流部","loc":"北京"},{},{}
7.应用
    document对象,解析二进制数据和编译二进制命令,让各个命令都成为对象
    方法:
        getElementById("xx")
        getElementsByName("xx")
        getElementsByTagName("xx")
        getElementsByClassName("xx")
    对象方法:
        innerHTML 显示对象内容  可以进行赋值
        style.color="red"
8.事件
   属性
      value属性
      checked属性   
      样式属性
   监听事件
      onkeydown    按下键盘
      onkeyup      松开键盘
      
      onclick      点击
      
      onfocus      当前标签获得光标时   -->focus()
      onblur       当前标签失去光标时
      
      onmouseover  鼠标悬浮在事件上
      onmouseout   鼠标离开事件
      
      onchange      鼠标改变了【下拉列表的选中项】
      
      onload        监听事件(提前将body的内容加载出来)      window.onload=函数名
     //凡是通过DOM对象绑定处理函数，在运行时无法得到实参。
     //凡是通过DOM对象绑定处理函数，在运行时不是window调用，而是当前标签的DOM对象调用
        //如果是window调用,要想当前的标签dom对象调用必须传参  fun(this)   fun(dom)接收
 绑定方式
    1.内嵌绑定,不适合项目开发
    2.通过标签绑定
     <tr></tr>
    <tr></tr>
     <tr></tr>
  var domList =document.getElementsByTagName("tr");
		for(var i=0;i<domList.length;i++){
			     var dom =domList[i];
			     dom.onmouseover=fun1;
```

# Java Web核心技术

## 常见的HTTP状态码

```
  1) 200：本次访问的资源文件已经存入到响应体中

2) 302: 要求浏览器将响应头location属性的地址更新到浏览器的地址栏上

3) 404: 由于服务端没有存在需要的文件，所以无法提供服务

	        原因1:网站名或则资源文件名书写错误
		原因2:URI格式忘记书写开头斜线
		原因3:有两个以上的servlet的value值或则name值相同了
		
 4) 405: 由于本次访问的Servlet无法处理本次的请求方式，所以无法提供服务
                        GET
               浏览器------->Tomcat------>oneServlet.doGet()
                        POST
	       浏览器------->Tomcat------>oneServlet.doPost()
                       GET
	       浏览器------->Tomcat----> OneServlet没有重写doGet
	               405   <-----
 5) 500: 由于本次访问的Servlet在运行时出现异常，所以无法提供服务

```

## Tomcat与HTTP Servlet

```xml
xml的配置   -->key  value
<servlet>
        <servlet-name>key1</servlet-name>
        <servlet-class>com.bjpowernode.control.OneServlet</servlet-class>
        <load-on-startup>500</load-on-startup>  <!-- 设置servlet加载 大于-1的一个数,数字越小越小越先辈执行  构造方法-->
    </servlet>
 
    <servlet-mapping>
        <servlet-name>key1</servlet-name>
        <url-pattern>/one</url-pattern>         <!-- 设置网站访问名字 -->
    </servlet-mapping>

注解
  @WebServlet(value = "/three",loadOnStartup = 80)    <!--value网站访问名字  loadOnStarup 设置Servlet加载-->
```

```java
get和post使用场景
    get :  可提供参数:超链接,表单域
           不可提供参数:表单,地址栏
    post: 文件上传,登录验证,索要实时数据
        
doGet/doPost
    HttpServletRequest req, HttpServletResponse resp
    
    Stirng xx=req.getParameter("xx");             //请求行
    String url = req.getRequestURL().toString();  //请求行
    String uri = req.getRequestURI().toString();  //请求行
    String method = req.getMethod();              //请求行
     req.setCharacterEncoding("utf-8");           //请求头

    resp.setContentType("text/html;charset=utf-8");  //响应头
    PrintWriter out=resp.getWriter();                //响应体内容
    out.print();

重定向   -->302状态码判断是否进行了重定向,重定向的请求一定是get
  resp.sendRedirect("/exam/add")                   //响应头   -->302状态码
    1.外部网站   "www.baidu.com"
    2.内部网站   "/exam/find" 
    
请求与转发   转发的请求与第一次请求相同
       //请求与转发 1.请求对象生成 虚拟请求包  2.虚拟请求包发送给Http服务器
        RequestDispatcher rd = req.getRequestDispatcher("/find");
        rd.forward(req, resp);

```

![image-20240423094457509](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240423094457509.png)

重定向![image-20240427153905797](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240427153905797.png)

请求与转发![image-20240427193402664](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240427193402664.png)

## Servlet之间数据共享

cookie![image-20240428092213275](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240428092213275.png)

```java
1.用户第一次来时，为用户提供服务文件
    Cookie c1=new Cookie("name","mike");
    Cookie c2=new Cookie("value", "300");
        //设置cookie时间
    c1.setMaxAge(60*1);
        //在服务结束时，通过响应对象将用户的Cookie写入到响应头，交给用户浏览器保管
    resp.addCookie(c1);  //客户端计算机磁盘上
    resp.addCookie(c2);  //客户端计算机上浏览器所管理的内存中
2.用户第二次来时，为用户提供服务文件
    //1.在TwoServlet提供服务期间，要求请求对象读取当前请求头中Cookie
        Cookie array[]=req.getCookies();
        //2.TwoServlet读取Cookie信息(之前为当前用户提供服务的OneServlet写入)
        for (Cookie cookie : array) {
            String key = cookie.getName();
            String value = cookie.getValue();
            System.out.println("key = " + key + " value= " + value);
        }
```

HttpSession![image-20240428105501004](C:\Users\小谢专用free\AppData\Roaming\Typora\typora-user-images\image-20240428105501004.png)

```java
    HashTable是占用整个哈希表,虽然安全,但是效率太慢
    ConcurrentHashMap占用哈希表的某一个索引值,安全且效率高
1.用户第一次来时，为用户提供服务文件
        HttpSession session=req.getSession(true);
        session.setAttribute("money",3000);
        session.setAttribute("name", "mike");
 /* 本次服务结束时
     *
     *  1.Http服务器，将当前用户柜子编号保存到Cookie(手牌)
     *    Cookie c = new Cookie("jsessionid","用户柜子编号")
     *  2.Http服务器，调用响应对象将Cookie写入到响应头，交给浏览器保管
     *    resp.addCookie(c);
     */
2.用户第二次来时，为用户提供服务文件

        HttpSession session = req.getSession(true);
        int money=(int)session.getAttribute("money");
        String name= (String) session.getAttribute("name");
        System.out.println("money = "+money+" ,name= "+name);
自动保存为30分钟  
    <!--       自定义session最大空闲时间-->
    <session-config>
        <session-timeout>5</session-timeout>
    </session-config>
```

ServletContext接口      ->不建议使用

```java
1.委托请求对象 创建全局作用对象
        ServletContext context = req.getServletContext();
        context.setAttribute("key1", "value1");
        context.removeAttribute("key1")
2.用户第二次来时，全局作用域对象为用户提供服务文件
        ServletContext context = req.getServletContext();
        System.out.println(context.getAttribute("key1"));     
```

HttpServletRequest接口

```java
请求转发建议使用此接口的数据共享
 1.将共享数据，放入【请求作用域对象】
        req.setAttribute("key1", "花生");

     委托【请求对象】生成一个虚拟请求包
        RequestDispatcher rd =req.getRequestDispatcher("/four");
      将【请求对象】和响应对象放入虚拟请求包并交给Tomcat
        rd.forward(req, resp);
2.从【请求作用域对象】读取数据
        String value =(String) req.getAttribute("key1");
        System.out.println("value = "+value);
```

欢迎页面

```xml
<welcome-file-list>
	    <welcome-file>insert.html</welcome-file>
</welcome-file-list>

 <!--       自定义session最大空闲时间-->
    <session-config>
        <session-timeout>5</session-timeout>
    </session-config>
```

## Filter过滤器

```xml
@WebFilter("/*")
   <filter>
               <filter-name>one</filter-name>
               <filter-class>xxx.xxx</filter-class>
           </filter>
    <filter-mapping>
        <filter-name>one</filter-name>
        <url-pattern>/add</url-pattern>
    </filter-mapping>
```

## Listener监听器

```xml
<!-- 谁是监听器 -->
<listener>
       <listener-class>com.bjpowernode.listener.xxx</listener-class>
 </listener>

@WebListener  

作用域对象:
 1） ServletContext     application: 全局作用域对象

 2） HttpSession        session    : 会话作用域对象

 3） HttpServletRequest request : 请求作用域对象

监听 ServletContext 的俩大接口
1.ServletContextListener接口    
       <!--   ServletContext context =sce.getServletContext();  获取当前监听对象的地址值 -->
          contextInitialized()
          contextDestroyed()      
2.ServletContextAttributeListener 接口
          attributeAdded() 
          attributeRemoved() 
          attributeReplaced() 
```

## 局部刷新

```html
异步请求对象
XmlHttpRequest
技术:  Ajax

请求三要素
   <script type="text/javascript">
   function  fun1(){
          <!-- axios.get(地址,{params:{ 参数列表 }}).then(返回结果的执行函数)-->
          axios.get("/exam/check",
                  {
                    params: {
                            "title":document.getElementById("title").value
                          }
                  }
          ).then(
                  function (response){
                     var data=response.data;
                     if (data>0){
                       document.getElementById("title").focus();
                       document.getElementById("smith").innerHTML="题目已存在";
                       document.getElementById("sb").disabled=true;
                     }else {
                       document.getElementById("smith").innerHTML="*";
                       document.getElementById("sb").disabled=false;
                     }
                  }
          )
        }
</script>

局部更新跳转:
    window.location.href="/exam/xxx";

json格式串:
        ObjectMapper mapper = new ObjectMapper();
        String jsonStr=null;

        jsonStr=mapper.writeValueAsString(entity);
        out.print(jsonStr);
在list数组中,取出其中一个entity类的所有属性值(通常为json)     list.get(0)
```

## Vue

```html
  el:          
             el:"#id编号"  根据id编号确认Vue对象管理标签是谁
              el:"标签类型名"根据标签类型确认Vue对象管理标签是谁
              el:".class"   根据标签class值(自定义样式选择器)Vue对象管理标签是谁
              el:document.getElementById(id编号)

<script type="text/javascript" src="/t/js/vue.js"></script>
 <script type="text/javascript">
         window.onload=function(){

             var vue = new Vue({
                 el: "#myDiv",
                 data:{
                     num1:100,
                     stu:{"sid":40,"sname":"SMITH"},
                      cityList:[
                            {"cid":10,"cname":"北京"},
                             {"cid":20,"cname":"天津"}
                          ]
                   },
                 methods:{
                   fun1:function (){
                      this.num1= this.num1*1+this.num2*1;
                   },
                  fun2:function(p1,p2){
                      this.num2=p1+p2;
                  }
              }
             });
         }
  </script>
<!--  event.target 获取当前的dom值   双目之间用 {{}} -->
1.   v-model:value="num"   <!-- num值随value值的变化而变化 -->
2.   v-on:click="fun1(p1,$event)"

3.   v-show=" num>=18 "  <!-- v-show 设置了不满足条件为隐藏  v-if 完全不执行 看不见-->
4.   v-if=" num>=18 "
5.   v-for="x in num"    <!-- x.sid  x.cname-->

```

# 流行框架技术

## Maven

### 概念

```
什么是maven
  它是一个一键式的自动化的构建工具.
  它负责添加jar包,管理插件,资源文件管理,依赖冲突的解决以及私服的搭建.
```

### POM

```xml
<properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- junit-->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <!-- mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.32</version>
        </dependency>
        <!-- mybatis-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.11</version>
        </dependency>
        <!-- 分页-->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
            <version>5.1.2</version>
        </dependency>
         <!-- servlet-->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
        <!--spring 日志框架-->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
        </dependency>
        <!--spring  框架-->
          <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.24</version>
        </dependency>
    </dependencies>

<!-- mybatis资源文件的指定-->
<build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                    <include>**/*.properties</include>
                </includes>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.xml</include>
                    <include>**/*.properties</include>
                </includes>
            </resource>
        </resources>
    </build>
```

## Mybatis

### 概念

```
1.为什么要动态代理
   业务逻辑层调用数据访问层的xml文件
   满足7个规范: 
        1.Mapper接口与Mapper.xml文件在同一个目录下
        2.Mapper接口的完全限定名与Mapper.xml文件中的namespace的值相同。
        3.Mapper接口方法名称与Mapper.xml中的标签的statement 的ID完全相同。
        4.Mapper接口方法的输入参数类型与Mapper.xml的每个sql的parameterType的类       型相同
        5.Mapper接口方法的输出参数与Mapper.xml的每个sql的resultType的类型相同。
        6.Mapper文件中的namespace的值是接口的完全限定名称.
        7.在SqlMapConfig.xml文件中注册时,使用class属性=接口的完全限定名.
 2.动态sql
      一组标签,简化sql代码的书写
 3.缓存  
      提高数据访问效率
 4.MyBatis是一款轻量级的半自动化对象关系映射（ORM）框架。
```

### Config文件

```xml
<!-- SqlMaoConfig.xml-->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
   <properties resource="jdbc5.properties"></properties>
    <!--日志-->
    <settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
        <!--实体类别名  批量package-->
    <typeAliases >
        <!--个别: <typeAliases type="com.bjpowernode.pojo.Users" alias="users" >-->
        <package name="com.bjpowernode.pojo"/>
    </typeAliases>
      <!--分页查询的插件-->
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
    </plugins>
    <environments default="cgg">
        <environment id="cgg">
            <transactionManager type="JDBC"></transactionManager>
          <!--  
    type:
             JDBC:程序员自己控制事务的提交和回滚
             MANAGED:容器控制事务的提交和回滚
    type:
            JNDI:Java命名目录接口,是服务器端维护的数据库连接池
            POOLED:数据库连接池
            UNPOOLED:不使用数据库连接池
-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driverClassName}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
<!--        <mapper url="D:/course-dljd/10-MyBatis/code/mybatisall/mybatis_002_users/src/main/java/com/bjpowernode                          /mapper/UsersMapper.xml"></mapper>-->
<!--        <mapper resource="com/bjpowernode/mapper/UsersMapper.xml"></mapper>-->
<!--        <mapper class="com.bjpowernode.mapper.UsersMapper"></mapper>-->
        <package name="com.bjpowernode.mapper"/>
    </mappers>
</configuration>
```

### Mapper文件

```xml
<!-- UsersMapper.xml  -->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="zsh">
    
</mapper>
```

### 代码实现

```java
 @Test
    public void getByNameLike() throws IOException {
        InputStream in=Resources.getResourceAsStream("SqlMapConfig.xml");
        SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(in);
        SqlSession sqlSession=factory.openSession(true);  //设置事务自动提交
        UserMapper  usermapper=sqlsession.getMapper(UserMapper.class)
        //List<Student> list = sqlSession.selectList("xcl.getByNameLike", "test%");
        sqlSession.close();
    }
```

```properties
#jdbc5.properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&characterEncoding=utf8
jdbc.username=root
jdbc.password=123
```

### 分页代码

```java
  //分页代码  limit (0,5)
public void getAllPackage(){
        PageHelper.startPage(2, 5);
        List<Users> list=usersMapper.getAll();
        PageInfo<Users> info=new PageInfo<>(list);
        //System.out.println(info);
        info.getList().forEach(users -> System.out.println(users));
    }
    行数 (p-1)*num
   private int pageNum;     //当前页
    private int pageSize;   //当前的行数
    private int size;       //每一页指定的行数
    private int startRow;   //当前页开始的行数
    private int endRow;     //当前页最后的行数
    private long total;     //总行数
```

### mybatis代码

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.bjpowernode.mapper.UsersMapper">
    <sql id="sumNum">
        id,username,birthday,sex,address
    </sql>
    <select id="getAll" resultType="users">
        select <include refid="sumNum"></include>
        from users
    </select>
    <select id="getByID" resultType="users" parameterType="int">
        select <include refid="sumNum"></include>
        from users
        where id=#{id}
    </select>
    <insert id="insert" parameterType="users">
        insert into users(username,birthday,sex,address)
        values(#{userName},#{birthday},#{sex},#{address})
    </insert>
    <update id="update" parameterType="users">
        update users set username=#{userName},birthday=#{birthday},sex=#{sex},address=#{address}
        where id=#{id}
    </update>
   ----------------------------------------------------------------------------------------
    <!-- @Param(xxx) xx -->
    <delete id="delete" >
        delete from users where id=#{id} and username=#{name}
    </delete>
    
    <select id="getByNameLast" resultType="users" parameterType="string">
        select <include refid="sumNum"></include>
        from users
        where username like concat('%',#{userName},'%')
    </select>
----------------------------------------------------------------------------------------
     <!-- ${}和#{}的区别   sql注入风险-->
    <select id="getByOther" resultType="users">
        select <include refid="sumNum"></include>
        from users
        where ${colName} like concat('%',#{colValue},'%')
    </select>
    
----------------------------------------------------------------------------------------
 <!-- 条件判断 -->
    <select id="getByCondition" resultType="users" parameterType="users">
        select <include refid="sumNum"></include>
        from users
        <where>
            <if test="userName != null and userName !=''">
                and username=#{userName}
            </if>
            <if test="birthday != null ">
                and birthday=#{birthday}
            </if>
            <if test="sex != null and sex != ''">
                and sex=#{sex}
            </if>
            <if test="address != null and address != ''">
                and address=#{address}
            </if>
        </where>
    </select>
    <update id="updateById" parameterType="users">
        update users
        <set>
            <if test="userName !=null and userName != ''">
                ,username=#{userName}
            </if>
            <if test="birthday !=null ">
                ,birthday=#{birthday}
            </if>
            <if test="sex !=null and sex != ''">
                ,sex=#{sex}
            </if>
            <if test="address !=null and address != ''">
                ,address=#{address}
            </if>
        </set>
        where id =#{id}
    </update>
    <!-- 循环   collection 的三个类型 
                         array      数组
                         list       list集合
                         map的key值  map集合
-->
    <select id="getByIdFor" resultType="users">
        select <include refid="sumNum"></include>
        from users
        where id in
        <foreach collection="array" item="id" separator="," open="(" close=")">
            #{id}
        </foreach>
    </select>
    <delete id="deleteByIdFor">
          delete from users where id in
        <foreach collection="array" item="id" separator=","  open="(" close=")">
            #{id}
        </foreach>
    </delete>
    <insert id="insertByIdFor" >
        insert into users(username,birthday,sex,address)
        values
            <foreach collection="list" item="user" separator=",">
                (#{user.userName},#{user.birthday},#{user.sex},#{user.address})
            </foreach>
    </insert>
    <update id="updateByIdFor" parameterType="map">
        update users
        set username=#{name},birthday=#{day}
        where id in
        <foreach collection="p" item="o" separator="," open="(" close=")">
            #{o}
        </foreach>
    </update>
    
----------------------------------------------------------------------------------------
     <!-- 多个参数可以不用@Param()  用#{argx} -->
     <select id="getAllParam" resultType="users">
         select <include refid="sumNum"></include>
         from users
         where birthday between #{arg0} and #{arg1}
     </select>
    
----------------------------------------------------------------------------------------  
     <!-- map参数传入 -->
       map.put("name","小陈");
       map.put("p",px{1,3,5})
    <select id="getParamMap" resultType="users" parameterType="map">
        select <include refid="sumNum"></include>
        from users
        where username=#{name} or address in
        <foreach collection="p" item="o" separator="," open="(" close=")">
            #{o}
        </foreach>
    </select>
     <!-- map参数返回 -->
    <select id="getReturnMapOne" resultType="map" parameterType="int">
        select username as myname,address as myaddress,birthday as day
        from users
        where id=#{id}
    </select>
    <select id="getReturnMapMul" resultType="map">
        select username myname,address myaddress
        from users
    </select>
</mapper>
----------------------------------------------------------------------------------------
<!-- 返回主键标签   在一个业务中有多张表的操作，下一个操作会用到上一个操作生在怕主键信息-->
 <selectKey order="AFTER" keyProperty="id" resultType="int">
            select LAST_INSERT_ID()
            select uuid()
 </selectKey>
----------------------------------------------------------------------------------------
```

### ORM

```xml
对象关系映射
持久层   数据库增删改查操作
持久化   将对象保存到关系型数据库中 ,将关系型数据库中的数据读取出来以对象的形式封装
<!--一对多/多对多  list集合-->
<mapper namespace="com.bjpowernode.mapper.CustomerMapper">
    <resultMap id="MyMap" type="customer">
        <id property="id" column="cid"></id>
        <result property="name" column="name"></result>
        <result property="age" column="age"></result>
        <collection property="ordersList" ofType="orders">
            <id property="id" column="oid"></id>
            <result property="orderNumber" column="orderNumber"></result>
            <result property="orderPrice" column="orderPrice"></result>
        </collection>
    </resultMap>
    <select id="getByID" resultMap="MyMap" parameterType="int">
        select c.id cid,name,age,o.id oid,orderNumber,orderPrice,customer_id
        from customer c left join orders o on c.id=customer_id
        where c.id=#{id}
    </select>
</mapper>
----------------------------------------------------------------------------------
<!-- 多对一/一对一   对象-->
<mapper namespace="com.bjpowernode.mapper.OrdersMapper">
    <resultMap id="MyOrders" type="orders">
        <id property="id" column="oid"></id>
        <result property="orderNumber" column="orderNumber"></result>
        <result property="orderPrice" column="orderPrice"></result>
        <association property="myCustomer" javaType="customer">
            <id property="id" column="cid"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
        </association>
    </resultMap>
    <select id="getById" resultMap="MyOrders" parameterType="int">
        select o.id oid,orderNumber,orderPrice,customer_id,c.id cid,name,age
        from orders o join customer c on customer_id=c.id
        where o.id=#{id}
    </select>
</mapper>
-------------------------------------------------------------------------------------
第二种方法
<mapper namespace="com.bjpowernode.mapper.CustomerMapper">
<!--       Customer getByIDLevel(Integer id);-->
    <resultMap id="customerMap" type="customer">
        <id property="id" column="cid"></id>
        <result property="name" column="name"></result>
        <result property="age" column="age"></result>
        <collection property="ordersList" ofType="orders" column="id"
                    select="com.bjpowernode.mapper.OrdersMapper.selectOrdersByCustomerId">
        </collection>
    </resultMap>
    <select id="getByIDLevel" resultMap="customerMap" parameterType="int">
        select * from customer where id=#{id}
    </select>
<!--     Customer findCustomerByOrdersCustomerid(Integer id);-->
    <select id="findCustomerByOrdersCustomerid" parameterType="int" resultType="customer">
        select * from customer where id=#{id}
    </select>
</mapper>

<mapper namespace="com.bjpowernode.mapper.OrdersMapper">
    <resultMap id="ordersMap" type="order">
        <id property="id" column="oid"></id>
        <result property="orderNumber" column="orderNumber"></result>
        <result property="orderPrice" column="orderPrice"></result>
        <association property="myCustomer" javaType="customer" column="customer_id"
                     select="com.bjpowernode.mapper.CustomerMapper.findCustomerByOrdersCustomerid">
        </association>
    </resultMap>
<!--    Orders getByIdLevel(Integer id);-->
    <select id="getByIdLevel" resultMap="ordersMap" parameterType="int">
        select * from orders where id=#{id}
    </select>
<!--   List<Orders> selectOrdersByCustomerId(Integer id);-->
    <select id="selectOrdersByCustomerId" resultType="orders" parameterType="int">
        select * from orders where customer_id=#{id}
    </select>
</mapper>
```

### 缓存

```xml
   <!--当开启二级缓存后，数据的查询执行流程是先检查二级缓存，然后是一级缓存，最后是数据库(自动添加到缓存)-->
一级缓存(系统默认)
    读取数据先在内存的缓存中去读取,如果有直接拿,则不用去数据库拿(在缓存中拿取的对象是同一个)
    增删改则会将缓存清空
    同一个SqlSession内部使用的缓存,一级缓存的生命周期与SqlSession绑定，当SqlSession结束时，一级缓存中的数据也会被清除。
二级缓存(需要手动开启)
   在不同的SqlSession中有不同的内存地址,取到缓存中的对象内存地址也不相同
   MyBatis的二级缓存在遇到数据进行增删改操作时，会自动清空缓存。
   可以被多个SqlSession共享。二级缓存是基于Mapper的namespace级别进行管理的

    SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存，并且要让实体类实现serializable接口
    1.<setting name="cacheEnabled" value="true"/>
    2. <cache></cache>
    3.实体类 xx implement serializable
```

## Spring

### 概念

```
1.什么是Spring框架
  它是极好的解耦合的框架.
  它是一个容器,它是用来整合其它框架的框架.使其它框架更易用.
  它的核心是IOC(控制反转)和AOP(面向切面编程).
  它是一个庞大的家族,包含Spring, SpringMVC, SpringBoot, SpringCloud等.
  它在很多领域提供了优秀解决方案,微服务,云存储,批处理,事件驱动等等.
2.Spring框架的优点
  1)轻量级
    它的核心jar包很小,总共3M左右.
    对代码零污染.
  2)面向接口编程
    A.类中的成员变量设计为接口
    B.方法的参数设计为接口
    C.方法的返回值设计为接口
    D.调用时接口指向实现类
      接口可以多继承多实现.
      上接口就是上灵活
3. 面向切面编程AOP
    切面就是那些重复的,公共的,通用的功能(非主业务逻辑)称为切面.
    面向切面编程是将切面单拎出来开发(MyBatis中用过的@Before@After),在主业务逻辑(@Test功能)调用时自动反织回来的功能称为AOP.
4. 控制反转IOC
  什么是控制?  创建对象和依赖注入的控制权
  什么反转?    反转给Spring容器
  IOC:由spring来创建对象和注入依赖
```

```
面向对象（OOP）：
  核心在于通过对象来模拟现实世界的实体和行为。
  主要关注类的设计和对象的创建以及这些对象之间的交互。
  封装、继承和多态是其核心概念。
  目的是通过对象的方法来操作数据，而不是直接操作数据。
  
面向接口(IOP)：-->灵活性
  侧重于定义和实现接口，即定义方法的签名而不包含具体的实现。
  强调在设计时依赖于抽象而不是具体实现，降低模块间的耦合度。
  任何实现该接口的类都必须提供这些方法的具体实现。
  实现分离意味着接口的实现可以被替换，只要新的实现遵循相同的接口规范。
  
面向切面（AOP）：
  是对业务逻辑进一步的抽取，将多种业务逻辑中的公用部分抽取出来做成一种服务。
  这种服务通过配置可以动态地给程序添加统一控制，例如日志记录、性能统计、安全验证等。
  利用AOP可以对业务逻辑的各个部分进行分离，从而使得业务逻辑各部分之间的耦合度降低。
  简单的总结：将各个业务中的公共部分抽取出来，实现代码的复用的一种编程方法。
```

### IOC

[^]: spring容器获取时,自动创建对象

```xml
基于XML的实现
<!--   setxxx() 方法注入  -->
    <bean id="s1" class="com.bjpowernode.sd1.School">
       <property name="name" value="北京大学"></property>
       <property name="address" value="北京"></property>
   </bean>
    <bean id="s2" class="com.bjpowernode.sd1.Student">
        <property name="name" value="小陈"></property>
        <property name="age" value="18"></property>
        <property name="school" ref="s1"></property>
     </bean>
<!--  构造方法 注入的三种方式-->
   1.name值对应
    <bean id="s1" class="com.bjpowernode.sd2.School">
        <constructor-arg name="name1" value="南京大学"></constructor-arg>
        <constructor-arg name="address1" value="江苏"></constructor-arg>
  </bean>
   2.index下标
    <bean id="s2" class="com.bjpowernode.sd2.Student">
        <constructor-arg index="0" value="小陈"></constructor-arg>
        <constructor-arg index="1" value="18"></constructor-arg>
        <constructor-arg index="2" ref="s1"></constructor-arg>
    </bean>
    3.默认值
    <bean id="s3" class="com.bjpowernode.sd2.Student">
        <constructor-arg value="小刚"></constructor-arg>
        <constructor-arg value="26"></constructor-arg>
        <constructor-arg ref="s1"></constructor-arg>
    </bean>
---------------------------------------------------------------------------
xml创建系统类型对象
<bean id="myDate" class="java.util.Date" >
  </bean>
---------------------------------------------------------------------------
作用域
   singleton多次取同一个对象  prototype每次取都创建一个对象
  <bean scope="prototype/singleton"></bean>
---------------------------------------------------------------------------
引用类型的成员变量自动注入值(autowire )
 <bean id="s" class="com.xxx.Student">
        <constructor-arg index="2" ref="s1"></constructor-arg>
 </bean>
优化-->
   1.byName  根据名称自动注入(在整个Bean工厂中找到同名的对象注入)
      <bean id="s" class="com.xxx.Student" autowire="byName" > </bean>
   2.byType  根据类型自动注入(在整个Bean工厂中找到同类型的对象注入)
       <bean id="s" class="com.xxx.Student" autowire="byType" > </bean>
---------------------------------------------------------------------------
实现:
ApplicationContext ac=new ClassPathXmlApplicationContext("sd/applicationContext.xml");
        Student student= (Student) ac.getBean("stu");
```

```xml
基于注解的实现
1.包扫描
  可以同时扫描多个包,多个包之间以逗号或分号或空格隔开.
 <context:component-scan base-package="com.bjpower.controller"></context:component-scan>
2.注解
  2.1创建对象
  @Component: 创建任意对象,可以自定义对象的名称,也可以使用默认的名称(类名的驼峰命名法).
  @Controller:创建界面层的对象,用来接收客户端的输入,调用业务逻辑层并返回结果给客户端.
  @Service:创建业务逻辑层的对象,完成真正的业务功能,向上为界面层提供处理结果,向下问数据访问层要数据.
  @Repository:创建数据访问层的对象,完成数据库的增删改查功能.
  2.2注入依赖
    @Autowired: 按类型依赖注入,如果有多个相同类型(同源)则按名称来注入,默认是类的 "驼峰" 写法

    @Autowired
    @Qualifier("名称"):俩注解一起使用,按名称注入值

   JDK注解 @Resource  是 @Autowired和 @Qualifier 的总和
  同源类型(相当于同一个类型)
      A.被注入值的对象(Student中的school)的类型与注入值的对象类型(Bean工厂中创建好的对象)完全一致
      B.被注入值的对象(Student中的school---父)的类型与注入值的对象类型(Bean工厂中创建好的对象---子)是父子类
      C.被注入值的对象(Student中的school---接口)的类型与注入值的对象类型(Bean工厂中创建好的对象---实现类)是接口和实现类
3.拆分策略与整合
 拆分
   1)按层拆
       mapper   service    controller
   2)按模块拆
       user   book
 整合
    单个: <import resource="applicationContext_mapper.xml">
    批量: <import resource="applicationContext_*.xml">
```

### AOP日志配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--
  scan,当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
  scanPeriod,设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。
  debug,当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。

-->
<configuration debug="false" scan="true" scanPeriod="1 seconds">

    <!--
    contextName ，设置日志上下文名称，可以通过%contextName来打印日志上下文名称
    -->
    <contextName>logback</contextName>
    <!--
    property可以用来设置变量，可以通过${name}来访问，有以下的属性
        name，用于${name}访问的key
        value，用于${name}访问的value
        file ，用于指定配置文件的路径，他的作用在于，如果你有多个配置信息的话，可以直接写在配置文件中，然后通过file引入
               <property file="src/main/java/chapters/configuration/variables.properties" />
        resource作用和file一样，但是，它是可以直接从classpath路径下引入配置文件
               <property resource="resource.properties" />
    -->
    <property name="log.path" value="E:\\logback.log"/>
    <!--
    appender格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。
    -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!-- <filter class="com.example.logback.filter.MyFilter" /> -->
        <!--
        系统定义的拦截器，例如我们用ThresholdFilter来过滤掉INFO级别以下的日志不输出到控制台中
        -->
        <!--<filter class="ch.qos.logback.classic.filter.ThresholdFilter">-->
            <!--&lt;!&ndash;-->
            <!--Logger可以被分配级别。级别包括：TRACE、DEBUG、INFO、WARN和ERROR，-->
           <!--程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。-->
           <!--如果设置级别为INFO，则优先级高于等于INFO级别（如：INFO、 WARN、ERROR）的日志信息将可以被输出,小于该级别的如DEBUG将不会被输出。为确保所有logger都能够最终继承一个级别，根logger总是有级别，默认情况下，这个级别是DEBUG。-->
            <!--&ndash;&gt;-->
            <!--<level>INFO</level>-->
        <!--</filter>-->
        <!--encoder和pattern节点组合用于具体输出的日志格式-->
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n
       <!--19:01:54.436 logback [main] ERROR com.bjpowernode.MyTest - error.....................xxx-->
            </pattern>
        </encoder>
    </appender>
    <appender name="file"
              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}</file>
        <!--
            rollingPolicy日志回滚策略，在这里我们用了TimeBasedRollingPolicy，基于时间的回滚策略,有以下子节点
            fileNamePattern，必要节点，可以用来设置指定时间的日志归档，例如我们上面的例子是每天将日志归档成一个zip包
            maxHistory ,可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件,，例如设置为30的话，则30天之后，旧的日志就会被删除
            totalSizeCap，可选节点，用来指定日志文件的上限大小，例如设置为3GB的话，那么到了这个值，就会删除旧的日志
-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}.%d{yyyy-MM-dd}.zip</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <!--
            %logger{36} 表示logger名字最长36个字符，否则按照句点分割
            %date{HH:mm:ss.SSS}输出日志的打印日志，模式语法与java.text.SimpleDateFormat 兼容。看上去%d就已经够好了
            可选的格式修饰符位于“%”和转换符之间。第一个可选修饰符是左对齐标志，符号是减号“-”；
            m / msg / message 输出应用程序提供的信息。
            t / thread 输出产生日志的线程名。
            p / le / level输出日志级别。
            -->
            <pattern>%date %level [%thread] %logger{36} [%file : %line] %msg%n
  <!-- 2024-05-13 19:01:54,436 ERROR [main] com.bjpowernode.MyTest [MyTest.java : 24] error....xx-->
            </pattern>
        </encoder>
    </appender>
    <!--
    root节点，必选节点，用来指定最基础的日志输出级别，他有俩个节点可以用来应用appender，格式化日志输出
    -->
    <root level="debug">
        <appender-ref ref="console"/>
        <appender-ref ref="file"/>
    </root>
    <!--logger节点，可选节点，用来具体指明包的日志输出级别，它将会覆盖root的输出级别-->
    <!--<logger name="com.example.logback" level="warn" />-->
</configuration>
<!--
    <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
      <version>1.2.11</version>
    </dependency>

     private static final Logger LOGGER= LoggerFactory.getLogger(Agent.class);
     LOGGER.info("事务开启...........");
-->
```

### AOP

```java
AOP 底层，就是采用动态代理模式实现的。采用了两种代理：JDK 的动态代理，与 CGLIB的动态代理。
1.日志框架
    日志实现（日志实现框架）：JDKLog、LogBack、log4j、log4j2
    日志门面（日志标准接口框架）：JCL（Jakarta Commons Logging）、slf4j（Simple Logging Facade for Java）
  1)导入LogBack的依赖
  2)添加配置文件(老师提供)  
  3)使用日志门面调用日志功能
 
 Logger logger = LoggerFactory.getLogger(MyTest.class);
    @Test
    public void testLogBack(){
        //日志输出  优先级 error > warn > info > debug
        logger.debug("debug.....................111222");
        logger.info("info.....................111222");
        logger.warn("warn.....................111222");
        logger.error("error.....................111222");
    }
```

```java
AOP框架
 1.静态代理
 public class Agent implements Service {
    //1.类中的成员变量设计为接口k
    Service yewu;   //灵活业务
    AOP  aop;  //灵活切面
    //2.方法的参数设计为接口
    public Agent(Service yewu, AOP aop){
        this.yewu = yewu;
        this.aop = aop;}
    @Override
    public void buy() {
        try {
            //调用时接口指向实现类
            //切面
            aop.before();
            //业务
            yewu.buy();
            //切面
            aop.after();
        } catch (Exception e) {
            aop.exception();
    }}}
      @Test
        Service service=new Agent(new BookServiceImpl(), new TranferAop());
        Service service1=new Agent(service, new LogAop());
        service1.buy();
--------------------------------------------------------------------------
2.动态代理
    public class ProxyFactory {
     public static Object getAgent(Service service,AOP aop){
         return Proxy.newProxyInstance(
                 service.getClass().getClassLoader(),
                 service.getClass().getInterfaces(),
                 new InvocationHandler() {
                     @Override
                     public Object invoke(
                             Object proxy,
                             Method method,
                             Object[] args) throws Throwable {
                         Object obj=null;
                         try {
                             aop.before();
                             obj=method.invoke(service, args);   //service中的方法
                             aop.after();
                         }catch (Exception e){
                             aop.rollback();
                         }
                         return obj;
                     }
                 }
         );
     }
}
@Test
    Service service= (Service) ProxyFactory.getAgent(new BookServiceImpl(), new TransAop());
    Service service1= (Service) ProxyFactory.getAgent(service, new LogAop());
    service1.buy();
-----------------------------------------------------------------
3.spring xml的代理模式
      <!--创建业务对象-->
    <bean id ="bookServiceTarget" class="com.bjpowernode.service.impl.BookServiceImpl"></bean>
    <!--创建切面的对象-->
    <bean id="logAdvice" class="com.bjpowernode.advice.LogAdvice"></bean>
    <!--绑定业务和切面-->
    <bean id="bookService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <!--配置业务接口-->
        <property name="interfaces" value="com.bjpowernode.service.BookService"></property>
        <!--配置切面-->
        <property name="interceptorNames">
            <list>
                <value>logAdvice</value>
            </list>
        </property>
        <!--织入-->
        <property name="target" ref="bookServiceTarget"></property>
    </bean>
```

```java
4.AOP注解 代理模式    ----->推荐使用
    1)pom文件
    2)@Aspect  声明为代理类
      @Before(value)  前置
      @AfterReturning(value,returning)  后置
    3)value属性-->指定代理给哪个类中的哪个方法
      execution(访问权限 方法返回值 方法声明(参数) 异常类型)  
      execution(* com.xyz.service.impl.*.*(..))
      execution(* *..service.*.*(..))   a.b.service.*.*(..)  a.b.c.d.service.*.*(..)
```



## SpringMVC

## Linux

## 源码分析

# 企业框架技术

## Git

## SpringBoot

## Mybatis-Plus

## RBAC权限设计

## JWT

# 分布式中间件

## Nginx

## OSS

## 移动支付

## Docker

## Redis

## RockerMQ

## Elasticsearch

## 搜索平台

## Java并发编程



# 微服务生态

## RPC

## SpringCloud

# 项目实战



# 设计模式

## 第 1 章 内容介绍和授课方式



### 1.1 Java 设计模式内容介绍



[![image-20210730084543759](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210730084543759.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210730084543759.png)

### 1.1.2设计模式的重要性



> 1. 软件工程中，**设计模式**（design pattern）是对软件设计中**普遍存在（反复出现）的各种问题，所提出的解决方案**。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990 年代从建筑设计领域引入到计算机科学的
> 2. 拿实际工作经历来说, 当一个项目开发完后，如果**客户提出增新功能**，怎么办?。（可扩展性,使用设计模式，软件具有很好的扩展性）
> 3. 如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (**维护性**[可读性、规范性])
> 4. ) 目前程序员门槛越来越高，一线 IT 公司(大厂)，都会问你在实际项目中**使用过什么设计模式，怎样使用的，解决了什么问题**。
> 5. **设计模式在软件中哪里**？面向对象(oo)=>功能模块[设计模式+算法(数据结构)]=>框架[使用到多种设计模式]=> 架构 [服务器集群]

## 第 2 章 设计模式七大原则



### 2.1 设计模式的目的



> 编写软件过程中，程序员面临着来自 **耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性** 等多方面的 挑战，设计模式是为了让程序(软件)，具有更好
>
> 1. 代码重用性 (即：相同功能的代码，不用多次编写)
> 2. 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
> 3. 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)
> 4. 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
> 5. 使程序呈现高内聚，低耦合的特性
>
> **分享金句**：
>
> 1. 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”
> 2. Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤

### 2.2 设计模式七大原则(重点)



> 1. 单一职责原则
> 2. 接口隔离原则
> 3. 依赖倒转(倒置)原则
> 4. 里氏替换原则
> 5. 开闭原则
> 6. 迪米特法则
> 7. 合成复用原则

### 2.3 单一职责原则



#### 2.3.1基本介绍



对类来说的，**即一个类应该只负责一项职责**。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更 而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2

#### 2.3.2应用实例



以交通工具案例讲解

##### 1) 方案 1 [分析说明]



```
public class SingleResponsibility1 { 
    public static void main(String[] args) {
    Vehicle vehicle = new Vehicle(); vehicle.run("摩托车");
    vehicle.run("汽车"); vehicle.run("飞机");
}
}
// 交通工具类 
/**方式 1  
1. 在方式 1 的 run 方法中，违反了单一职责原则 
2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可 **/
class Vehicle { 
    public void run(String vehicle) {
        System.out.println(vehicle + " 在公路上运行...."); } }
```



##### 2) 方案 2 [分析说明]



```
public class SingleResponsibility2 { 
    public static void main(String[] args) { 
        RoadVehicle roadVehicle = new RoadVehicle(); 
        roadVehicle.run("摩托车"); roadVehicle.run("汽车"); 
        AirVehicle airVehicle = new AirVehicle(); airVehicle.run("飞机"); } }
/**方案 2 的分析 
1. 遵守单一职责原则 
2. 但是这样做的改动很大，即将类分解，同时修改客户端 
3. 改进：直接修改 Vehicle 类，改动的代码会比较少=>方案 3 **/
class RoadVehicle { public void run(String vehicle) { System.out.println(vehicle + "公路运行"); } }
class AirVehicle { public void run(String vehicle) { System.out.println(vehicle + "天空运行"); }}
class WaterVehicle { public void run(String vehicle) { System.out.println(vehicle + "水中运行"); } }
```



##### 3) 方案 3 [分析说明]



```
public class SingleResponsibility3 { 
    public static void main(String[] args) { 
 Vehicle2 vehicle2 = new Vehicle2(); vehicle2.run("汽车"); vehicle2.runWater("轮船"); vehicle2.runAir("飞机"); } }
/**方式 3 的分析
  //1. 这种修改方法没有对原来的类做大的修改，只是增加方法 //2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责 **/
  class Vehicle2 { public void run(String vehicle) {System.out.println(vehicle + " 在公路上运行...."); }
      public void runAir(String vehicle) { System.out.println(vehicle + " 在天空上运行...."); }
      public void runWater(String vehicle) { System.out.println(vehicle + " 在水中行...."); }
```



#### 2.3.3单一职责原则注意事项和细节



> 1. 降低类的复杂度，一个类只负责一项职责。
> 2. 提高类的可读性，可维护性
> 3. 降低变更引起的风险
> 4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中 方法数量足够少，可以在方法级别保持单一职责原则

### 2.4 接口隔离原则(Interface Segregation Principle)



#### 2.4.1基本介绍



> 1. 客户端不应该依赖它不需要的接口，即**一个类对另一个类的依赖应该建立在最小的接口**上
> 2. 先看一张图：[![image-20210730160651302](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210730160651302.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210730160651302.png)
> 3. 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C
>
> 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。
>
> 1. 按隔离原则应当这样处理：
>
> **将接口** **Interface1** 拆分为**独立的几个接口(这里我们拆分成 3 个接口)**，类 A 和类 C 分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则

#### 2.4.2应用实例



##### 1.没有使用接口隔离原则代码



```
 public class Segregation1 { 
     public static void main(String[] args) { }
     interface Interface1 { 
         void operation1(); void operation2(); void operation3(); void operation4(); void operation5(); }
     class B implements Interface1 { 
         public void operation1() { System.out.println("B 实现了 operation1"); }
         public void operation2() { System.out.println("B 实现了 operation2"); }
         public void operation3() { System.out.println("B 实现了 operation3"); }
         public void operation4() { System.out.println("B 实现了 operation4"); }
         public void operation5() { System.out.println("B 实现了 operation5"); } }
     class D implements Interface1 { 
         public void operation1() { System.out.println("D 实现了 operation1"); }
         public void operation2() { System.out.println("D 实现了 operation2"); }
         public void operation3() { System.out.println("D 实现了 operation3"); }
         public void operation4() { System.out.println("D 实现了 operation4"); }
         public void operation5() { System.out.println("D 实现了 operation5"); } }
     class A { 
         //A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法
         public void depend1(Interface1 i) { i.operation1(); }
         public void depend2(Interface1 i) { i.operation2(); }
         public void depend3(Interface1 i) { i.operation3();
】 } }
     class C { 
         //C 类通过接口 Interface1 依赖(使用) D 类，但是只会用到 1,4,5 方法 
         public void depend1(Interface1 i) { i.operation1(); }
         public void depend4(Interface1 i) { i.operation4(); }
         public void depend5(Interface1 i) { i.operation5(); } }
```



##### 2.应传统方法的问题和使用接口隔离原则改进



1. 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么**类 B 和类 D 必须去实现他们不需要的方法**
2. 将接口 **Interface1** **拆分为独立的几个接口**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口

隔离原则

1. 接口 Interface1 中出现的方法，根据实际情况拆分为**三个**接口[![image-20210730161548051](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210730161548051.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210730161548051.png)

```
public class Segregation1 {
    public static void main(String[] args) {
        A a = new A();
        a.depend1(new B()); a.depend2(new B());a.depend3(new B());
        C c = new C();
        c.depend1(new D()); c.depend4(new D()); c.depend5(new D())
    }
}
interface Interface1 { void operation1();}
interface Interface2 {
    void operation2(); void operation3();}
interface Interface3 {
    void operation4();void operation5();}

class B implements Interface1, Interface2 {//实现了接口隔离的原则
    public void operation1() {System.out.println("B 实现了 operation1");}
    public void operation2() { System.out.println("B 实现了 operation2");}
    public void operation3() { System.out.println("B 实现了 operation3");}
}
class D implements Interface1, Interface3 {
    public void operation1() { System.out.println("D 实现了 operation1");}
    public void operation5() { System.out.println("D 实现了 operation5"); }
}
    }
class A { // A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法
    public void depend1(Interface1 i) {i.operation1();}
    public void depend2(Interface2 i) { i.operation2(); }
    public void depend3(Interface2 i) {i.operation3();}
}
class C { // C 类通过接口 Interface1,Interface3 依赖(使用) D 类，但是只会用到 1,4,5 方法 
    public void depend1(Interface1 i) {i.operation1(); }
    public void depend4(Interface3 i) {i.operation4(); }
    public void depend5(Interface3 i) { i.operation5(); }
}
```



### 2.5 依赖倒转原则



#### 2.5.1基本介绍



> 依赖倒转原则(Dependence Inversion Principle)是指：
>
> - 高层模块不应该依赖低层模块，二者都应该依赖其抽象
> - 抽象不应该依赖细节，细节应该依赖抽象
> - **依赖倒转(倒置)的中心思想是面向接口编程**
> - 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架 构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类
> - 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

#### 2.5.2应用实例



请编程完成 Person 接收消息 的功能。1) 实现方案 1 + 分析说明

```
public class DependecyInversion {
    public static void main(String[] args) {
        Person person = new Person();
        person.receive(new Email());
    }
}
class Email {
    public String getInfo() {return "电子邮件信息: hello,world";}
}
/*方式 1 分析 
//1. 简单，比较容易想到 
//2. 如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法 
//3. 解决思路：引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖 // 因为 Email, WeiXin 等等属于接收的范围，他们各自实现 IReceiver 接口就 ok, 这样我们就符号依赖倒转原则*/
class Person {
    public void receive(Email email) {System.out.println(email.getInfo());}
}
```



1. 实现方案 2(依赖倒转) + 分析说明

```
public class DependecyInversion {
    public static void main(String[] args) { 
        //客户端无需改变
        Person person = new Person();
        person.receive(new Email()); person.receive(new WeiXin());
    }
}
interface IReceiver {
     String getInfo();
}
class Email implements IReceiver {
    public String getInfo() {return "电子邮件信息: hello,world";}
}
class WeiXin implements IReceiver {
    public String getInfo() {return "微信信息: hello,ok";}
}
class Person {
   // 这里我们是对接口的依赖
    public void receive(IReceiver receiver) { system.out.pringSystem.out.println(receiver.getInfo()); }}
```



#### 2.5.3依赖关系传递的三种方式和应用案例



> 1. 接口传递
> 2. 构造方法传递
> 3. setter 方式传递

```
public class DependencyPass {
    public static void main(String[] args) {
        ChangHong changHong = new ChangHong();
        OpenAndClose openAndClose = new OpenAndClose();
        openAndClose.open(changHong);
        
        OpenAndClose openAndClose = new OpenAndClose(changHong);
        openAndClose.open();
        
        OpenAndClose openAndClose = new OpenAndClose();
        openAndClose.setTv(changHong);
        openAndClose.open();
    }
} 
//方式 1： 通过接口传递实现依赖 开关的接口
interface IOpenAndClose {
    public void open(ITV tv);
}
interface ITV {
    public void play();
}
class ChangHong implements ITV {
    @Override
    public void play() { System.out.println("长虹电视机，打开"); }
}
class OpenAndClose implements IOpenAndClose {
    public void open(ITV tv) {tv.play(); }
}  
//方式 2:通过构造方法依赖传递
interface IOpenAndClose {
    public void open();
}
interface ITV {
    public void play();
}
class OpenAndClose implements IOpenAndClose {
    public ITV tv;
    public OpenAndClose(ITV tv) { this.tv = tv; }
    public void open() { this.tv.play(); }
}
//方式三：通过 setter 方法进行依赖传递
interface IOpenAndClose {
    public void open();
    public void setTv(ITV tv);
}
interface ITV { public void play();}
class OpenAndClose implements IOpenAndClose {
    private ITV tv;
    public void setTv(ITV tv) { this.tv = tv;}
    public void open() { this.tv.play();}
}
class ChangHong implements ITV {
    @Override
    public void play() {System.out.println("长虹电视机，打开");}
}
```



#### 2.5.4依赖倒转原则的注意事项和细节



> 1. 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.
> 2. 变量的**声明类型尽量是抽象类或接口**, 这样我们的变量引用和实际对象间，就存在**一个缓冲层**，利于程序扩展 和优化
> 3. 继承时遵循**里氏替换**原则

### 2.6 里氏替换原则



#### 2.6.1OO 中的继承性的思考和说明



> 1. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
> 2. **继承在给程序设计带来便利的同时，也带来了弊端**。比如使用继承会给程序带来**侵入性**，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障
> 3. 问题提出：**在编程中，如何正确的使用继承**? => **里氏替换**原则

#### 2.6.2基本介绍



> - 里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。
> - 如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都 代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。**换句话说，所有引用基类的地*****方必须能透明地使用其子类的对象**。
> - 在使用继承时，遵循里氏替换原则，在**子类中尽量不要重写父类的方法**
> - 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合，组合，依赖** 来 解决问题

#### 2.6.3一个程序引出的问题和思考



```
public class Liskov {
    public static void main(String[] args) {
        A a = new A();
        System.out.println("11-3=" + a.func1(11, 3));
        System.out.println("1-8=" + a.func1(1, 8));
        System.out.println("-----------------------");
        B b = new B();
        System.out.println("11-3=" + b.func1(11, 3));
        System.out.println("1-8=" + b.func1(1, 8));
        System.out.println("11+3+9=" + b.func2(11, 3));
    }
}
class A {
    public int func1(int num1, int num2) { return num1 - num2;}
}
class B extends A {
    //无意识重写的代码。导致功能的改变
    public int func1(int a, int b) { return a + b;}
    public int func2(int a, int b) {return func1(a, b) + 9; }
}
```



#### 2.6.4解决方法



> - 通用的做法是：**原来的父类和子类都继承一个更通俗的基类**(子类中的共有方法写入到Base类中，供子类继承)，原有的继承关系去掉，采用**依赖，聚合，组合**等关系代替
> - 改进方案
>
> ![image-20210801092354793](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801092354793.png)

```
public class Liskov {
    public static void main(String[] args) {
        A a = new A();
        System.out.println("11-3=" + a.func1(11, 3));
        System.out.println("1-8=" + a.func1(1, 8));
        B b = new B();
    //  因为 B 类不再继承 A 类，因此调用者，不会再 func1 是求减法 调用完成的功能就会很明确 
        System.out.println("11+3=" + b.func1(11, 3));
        System.out.println("1+8=" + b.func1(1, 8));
        System.out.println("11+3+9=" + b.func2(11, 3));
        System.out.println("11-3=" + b.func3(11, 3));
    }
}
//创建一个更加基础的基类
class Base { /**A、B类中的共有功能写入到该类中 */}
class A extends Base {
    public int func1(int num1, int num2) {return num1 - num2; }}
class B extends Base {
    //使用组合关系
    private A a = new A();
    public int func1(int a, int b) { return a + b; }
    public int func2(int a, int b) { return func1(a, b) + 9; }
    public int func3(int a, int b) { return this.a.func1(a, b); }
}
```



### 2.7 开闭原则



##### 2.7.1基本介绍



> - 开闭原则（Open Closed Principle）是编程中**最基础、最重要**的设计原则
> - 一个软件实体如类，模块和函数应该对扩展开放**(对提供方)，对修改关闭(对使用方)**。用抽象构建框架，用实现扩展细节。
> - 当软件需要变化时，尽量**通过扩展软件**实体的行为来实现变化，而不是**通过修改**已有的代码来实现变化。
> - 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

##### 2.7.2看下面一段代码



[![image-20210801095005679](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801095005679.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801095005679.png)

```
public class Ocp {
    public static void main(String[] args) {
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
    }
}
//这是一个用于绘图的类[使用方]
class GraphicEditor {
    public void drawShape(Shape s) {
        if (s.m_type == 1) drawRectangle(s);
        else if (s.m_type == 2) drawCircle(s);//当添加功能时，需要修改使用方
    }
    public void drawRectangle(Shape r) { System.out.println(" 绘制矩形 "); }
    public void drawCircle(Shape r) { System.out.println(" 绘制圆形 "); }
    public void drawTriangle(Shape r) { System.out.println(" 绘制三角形 "); }}
class Shape {int m_type;}
class Rectangle extends Shape {
    Rectangle() { super.m_type = 1; }
}
class Circle extends Shape {
    Circle() {super.m_type = 2; }
}
```



##### 2.7.3方式 1 的优缺点



> - 优点是比较好理解，简单易操作。
> - 缺点是违反了设计模式的 ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的 时候，尽量不修改代码，或者尽可能少修改代码.
> - 比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多

##### 2.7.4改进的思路分析



> **思路**：把创建 **Shape** **类做成抽象类**，并提供一个**抽象的** **draw** 方法，让**子类去实现即可**，这样我们有新的图形 种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，**使用方的代码就不需要修** -> 满足了开闭原则

```
public class Ocp {
    public static void main(String[] args) {
         GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
    }
}
//这是一个用于绘图的类[使用方]（类似于依赖倒转）
class GraphicEditor {
    public void drawShape(Shape s) { s.draw(); }
}
//定义抽象类
abstract class Shape {
    int m_type;
    public abstract void draw();
}
class Rectangle extends Shape {
    Rectangle() { super.m_type = 1; }
    @Override
    public void draw() { System.out.println(" 绘制矩形 "); }
}
class Circle extends Shape {
    Circle() { super.m_type = 2; }
    @Override
    public void draw() { System.out.println(" 绘制圆形 "); }
}
```



### 2.8 迪米特法则



#### 2.8.1基本介绍



> - 一个对象应该对其他对象保持最少的了解
> - 类与类关系越密切，耦合度越大
> - 迪米特法则(Demeter Principle)又叫**最少知道原则**，即一个类**对自己依赖的类知道的越少越好**。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息
> - 迪米特法则还有个更简单的定义：**只与直接的朋友通信**
> - **直接的朋友**：每个对象都会与其他对象有**耦合关系**，只要两个对象之间有耦合关系，我们就说这两个对象之间 是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友，而出现在**局部变量中的类不是直接的朋友**。也就是说，陌生的类最好不要以局部变 量的形式出现在类的内部

#### 2.8.2应用实例



有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id

```
import java.util.ArrayList;
import java.util.List;
public class Demeter1 {
    public static void main(String[] args) {
        SchoolManager schoolManager = new SchoolManager();
        schoolManager.printAllEmployee(new CollegeManager());
    }
}
class CollegeEmployee {
    private String id;
    public void setId(String id) { this.id = id; }
    public String getId() { return id; }
}
class Employee {
    private String id;
    public void setId(String id) { this.id = id; }
    public String getId() { return id; }
}
class CollegeManager {
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) {
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工 id= " + i);
            list.add(emp);
        }
        return list;
    }
}
//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager
// CollegeEmployee 不是直接朋友 而是一个陌生类，这样违背了 迪米特法则
class SchoolManager {
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();
        for (int i = 0; i < 5; i++) {
            Employee emp = new Employee();
            emp.setId("学校总部员工 id= " + i);
            list.add(emp);
        }
        return list;
    }
        // 该方法完成输出学校总部和学院员工信息(id)
        void printAllEmployee (CollegeManager sub){
       /* 分析问题   1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友
                    2. CollegeEmployee 是以局部变量方式出现在 SchoolManager
                    3. 违反了 迪米特法则 获取到学院员工 */
            List<CollegeEmployee> list1 = sub.getAllEmployee();
            System.out.println("------------学院员工------------");
            for (CollegeEmployee e : list1) {
                System.out.println(e.getId());
            }
            List<Employee> list2 = this.getAllEmployee();
            System.out.println("------------学校总部员工------------");
            for (Employee e : list2) {
                System.out.println(e.getId());
            }
        }
    }
```



#### 2.8.3应用实例改进



前面设计的问题在于 SchoolManager 中，**CollegeEmployee** **类并不是** **SchoolManager** 类的直接朋友 (分析)

```
/*在学院管理类中添加此方法*/
public void printEmployee(){
        List<CollegeEmployee> list1=getAllEmployee();System.out.println("------------学院员工------------");
        for(CollegeEmployee e:list1){System.out.println(e.getId());}}
/*学校管理类中*/
//将输出学院的员工方法，封装到  CollegeManager 
sub.printEmployee();
```



#### 2.8.4迪米特法则注意事项和细节



> - 迪米特法则的核心是降低类之间的耦合
> - 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系

### 2.9 合成复用原则（Composite Reuse Principle）



#### 2.9.1基本介绍



> [![image-20210801110041438](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801110041438.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801110041438.png)

### 2.10 设计原则核心思想



> - 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
> - 针对接口编程，而不是针对实现编程。
> - 为了交互对象之间的**松耦合设计而努力**

## 第 3 章 UML 类图



### 3.1 UML 基本介绍



> - UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用 于帮助软件开发人员进行思考和记录思路的结果
>
> - UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如**类、接口、实现、泛化、依赖、组合、聚合**等，如右图:
>
> - > [![image-20210801154212001](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801154212001.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801154212001.png)
>   >
>   > [![image-20210801152853146](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801152853146.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801152853146.png)

### 3.2 UML 图



> UML 图分类：
>
> - 用例图(use case)
>
> - 静态结构图：**类图**、对象图、包图、组件图、部署图
>
> - 动态行为图：交互图（时序图与协作图）、状态图、活动图
>
> - 说明：
>
>   类图是描述类与类之间的关系的，是 UML 图中最核心的

### 3.3 UML 类图



> - 用于描述系统中的类**(对象)本身的组成和类(对象)之间的各种静态关系**。
>
> - 类之间的关系：**依赖、泛化（继承）、实现、关联、聚合与组合**。
>
> - 类图简单举例 [![image-20210801154729154](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801154729154.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801154729154.png)
>
> - > ```
>   > public class Person{ private Integer id; private String name; 			public void setName(String name){ this.name=name; }
>   >          public String getName(){ return name; } }
>   > ```
>   >
>   > 

### 3.4 类图—依赖关系（Dependence）



只要是**在类中用到了对方**，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。

```
class A{private B b;}
class B{}
```



[![image-20210801160841355](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801160841355.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801160841355.png)

> **小结**
>
> 1. 类中用到了对方 2) 如果是**类的成员属性** 3) 如果是**方法的返回类**型 4) 是方法**接收的参数类**型 5) **方法中使用**到

### 3.5 类图—泛化关系(generalization）



> - 泛化关系实际上就是继承关系
> - 如果 A 类继承了 B 类，我们就说 A 和 B 存在泛化关系

```
class A{}
class B extends A{}
```



[![image-20210801161122679](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801161122679.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801161122679.png)

###  3.6 类图—实现关系（Implementation）



```
interface A{}
class B implements a{}
```



[![image-20210801161309659](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801161309659.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801161309659.png)

### 3.7 类图—关联关系（Association）



[![image-20210801161357439](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801161357439.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801161357439.png)

### 3.8 类图—聚合关系（Aggregation）



#### 3.8.1基本介绍



> - 聚合关系（Aggregation）表示的是**整体和部分的关系**，**整体与部分可以分开**。聚合关系是**关联关系的特例**，所 以他具有关联的**导航性与多重性**。
>
> - > 如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来 的，使用带空心菱形的实线来表示

#### 3.8.2应用实例



[![image-20210801161533589](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801161533589.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801161533589.png)

### 3.9 类图—组合关系（Composition）



#### 3.9.1基本介绍



> - 组合关系：也是整体与部分的关系，但是**整体与部分不可以分开**。
>
> - 再看一个案例：在程序中我们定义实体：Person 与 IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。
>
> - > 但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那 么 IDCard 和 Person 就是组合了.

#### 3.9.2应用案例



```
public class Person{ 
    private IDCard card; 
    private Head head = new Head(); }
public class IDCard{} 
public class Head{}
```



[![image-20210801161749219](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801161749219.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801161749219.png)

## 第 4 章 设计模式概述



### 4.1设计模式介绍



> - 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，**模式不是代码**，而是**某类问题的通** **用解决方案**，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的 一段时间的试验和错误总结出来的。
> - 设计模式的本质提高 **软件的维护性，通用性和扩展性，并降低软件的复杂度**。
> - <<**设计模式**>> 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗 称 “四人组 GOF”）
> - 设计模式并不局限于某种语言，java，php，c++ 都有设计模式.

### 4.2 设计模式类型



设计模式分为**三种类型**，共 **23** **种**

> 1. **创建型**模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
> 2. **结构型**模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
> 3. **行为型**模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、 解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。

## 第 5 章 单例设计模式



### 5.1 单例设计模式介绍



**static 变量只依赖于类存在（类访问），不依赖于实例对象存在及内存中只有一份，共享一个变量**

> 所谓类的单例设计模式，就是**采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例**， 并且该类只提供一个取得其对象实例的方法(静态方法)。
>
> 比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是 轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。

### 5.2 单例设计模式八种方式



> 单例模式有八种方式：
>
> 1. **饿汉式(静态常量)**
> 2. **饿汉式（静态代码块）**
> 3. 懒汉式(线程不安全)
> 4. 懒汉式(线程安全，同步方法)
> 5. 懒汉式(线程安全，同步代码块)
> 6. **双重检查**
> 7. **静态内部类**
> 8. **枚举**

### 5.3 饿汉式（静态常量）



> 1. 构造器私有化 (防止 new )
> 2. 类的内部创建对象
> 3. 向外暴露一个静态的公共方法。getInstance

```
public class SingletonTest01 {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2);// true 
        System.out.println("instance.hashCode=" + instance.hashCode());
        System.out.println("instance2.hashCode=" + instance2.hashCode());
    }
}
class Singleton {
    private Singleton() {}
    //2.本类内部创建对象实例
    private final static Singleton instance = new Singleton(); 
    //3.提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() { return instance; }
}
```



> - **优缺点说明**：
>
> - > 1. 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
>   > 2. 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。**如果从始至终从未使用过这个实例，则会造成内存的浪费**
>   > 3. 这种方式基于 classloder 机制**避免了多线程的同步问题**，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果
>   > 4. **结论：这种单例模式可用，可能造成内存浪费**

### 5.4 饿汉式（静态代码块）



```
//饿汉式(静态变量)
class Singleton { 
    //1.构造器私有化,外部能 new
    private Singleton() {}
    //2.本类内部创建对象实例
    private static Singleton instance;
    static {
       // 在静态代码块中，创建单例对象 
        instance = new Singleton();
    }
    //3.提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}
```



> - 优缺点说明：
>
> - > 1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执 行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。
>   > 2. **结论：这种单例模式可用，但是可能造成内存浪费**

### 5.5 懒汉式(线程不安全)



```
class Singleton {
    private static Singleton instance;
    private Singleton() {}
    //提供一个静态的公有方法，当使用到该方法时，才去创建 instance
    //即懒汉式
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```



> - 优缺点说明：
>
> - > 1. 起到了 **Lazy Loading** 的效果，但是只能在单线程下使用。
>   > 2. 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过 了这个判断语句，这时便会**产生多个实例（可以理解为两个线程同时创建）**。所以在多线程环境下不可使用这种方式 (**单例模式是在整个系统中使用一个实例对象**)
>   > 3. 结论：在实际开发中，**不要使用**这种方式.

### 5.6 懒汉式(线程安全，同步方法)



```
//懒汉式(线程安全，同步方法)
class Singleton {
    private static Singleton instance;（静态属性，第一次调用下面的方法时赋值，并存在方法区得到静态池中）
    private Singleton() {}
    //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 
    // 即懒汉式
    public static synchronized Singleton getInstance() {//解决了多线程同时创建的问题
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```



> - 优缺点说明：
>
> - > 1. 解决了**线程安全**问题
>   > 2. 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行 一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。**方法进行同步效率太**低
>   > 3. 结论：在实际开发中，**不推荐**使用这种方式

### 5.7 懒汉式(线程安全，同步代码块)



没有实际的作用：[![image-20210801192449257](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801192449257.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801192449257.png)

### 5.8 双重检查 （DCL）



```
//懒汉式(线程安全，同步方法)
class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题,同时解决懒加载问题.同时保证了效率, 推荐使用
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```



> - 优缺点说明：
>
> - > 1. Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这 样就可以保证线程安全了。
>   > 2. 这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避 免的反复进行方法同步.
>   > 3. **线程安全**；**延迟加载**；**效率较高**
>   > 4. 结论：在实际开发中，**推荐使用这种单例设计模**式

[[java中volatile关键字的作用](https://www.cnblogs.com/ustc-anmin/p/11434769.html)]

> - ```
>   private volatile boolean pleaseStop;
>   ```
>
>   
>
> - 一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。以下例子展现了volatile的作用.
>
> - 假如pleaseStop没有被声明为volatile，线程执行run的时候检查的是自己的副本，就不能及时得知其他线程已经调用tellMeToStop()修改了pleaseStop的值。
>
> - Volatile一般情况下不能代替sychronized，因为**volatile不能保证操作的原子性**，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，**假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，**但依然可能出现写入脏数据的情况。如果配合Java 5增加的atomic wrapper classes，对它们的increase之类的操作就不需sychronized。

### 5.9 静态内部类



```
//静态内部类完成， 推荐使用
class Singleton {
    private static volatile Singleton instance;
    //构造器私有化
    private Singleton() {}
    //写一个静态内部类,该类中有一个静态属性 Singleton
    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }
//    提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE
    public static synchronized Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```



> - 优缺点说明：
>
> - > - 这种方式采用了类装载的机制来保证初始化实例时只有一个线程
>   > - 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才 会装载 SingletonInstance 类，从而完成Singleton 的实例化。
>   > - **类的静态属性只会在第一次加载类的时候初始化**，所以在这里，**JVM 帮助我们保证了线程的安全性，在类进行 初始化时，别的线程是无法进入的**。
>   > - 优点：**避免了线程不安全，利用静态内部类特点实现延迟加载，效率**高

### 5.10 枚举



```
//使用枚举，可以实现单例, 推荐
enum Singleton {
INSTANCE; //属性 
public void sayOK() { System.out.println("ok~"); } }
```



> - 优缺点说明
>
> - > 1. 这借助 JDK1.5 中添加的**枚举(内部也是静态代码块进行的实例化)**来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建 新的对象。
>   > 2. 这种方式是 **Effective Java** **作者** **Josh Bloch** **提倡**的方式
>   > 3. 结论：**推荐**使用

### 5.11 单例模式在 JDK 应用的源码分析



#### 5.11.1 单例模式在 JDK 应用的源码分析



java.lang.Runtime 就是经典的单例模式(饿汉式) [![image-20210801194529354](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801194529354.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801194529354.png)

### 5.12 单例模式注意事项和细节说明



> - 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
> - 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new
> - 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级 对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如**数据源**、**session** **工厂**等)

### 5.13重点



> - **反射是可以破坏以上的单例模式（除去枚举单例模式）**
> - **从源码中可以看出，当反射遇到枚举时直接抛出异常，因此，枚举是创建单例的不二之选**

### 5.14五种实现单例模式的方式的对比



> - 饿汉式：线程安全（不排除反射），调用效率高，不能延时加载
> - 懒汉式：线程安全（不排除反射）,调用效率不高，可以延时加载
> - DCL懒汉式：由于JVM底层模型原因，偶尔出现问题，不建议使用
> - 静态内部类式：线程安全（不排除反射），调用效率高，可以延时加载
> - 枚举单例：线程安全，调用效率高，不能延时加载

## 第 6 章 工厂模式



### 6.1核心本质:



> - 实例化对象不适用new, 用工厂方法代替
> - 将选择实现类，创建对象统一管理和控制，从而将调用者跟我们的实现类解耦

### 6.2三种模式:



> - 简单工厂模式
>   - 用来生产同一等级结构中的任何产品(对于增加新的产品，需要扩展已有代码)
> - 工厂方法模式
>   - 用来生产同一等级结构中的固定产品(支持增加任意产品)
> - 抽象工厂模式
>   - 围绕一个超级工厂创建其他工厂，该超级工厂又被称为其他工厂的工厂

### 6.3简单工厂模式(静态工厂模式 )



```
//定义一个接口
public interface Car
{
    void name();
}
//接口的实现类
public class WuLing implements Car
{
    @Override
    public void name(){System.out.println("五菱宏光！");}
}
public class Model implements Car
{
    @Override
    public void name() {System.out.println("特斯拉！"); }
}
//简单工厂
// 静态工厂模式
public class CarFactory
{
    // 方法一  违反了开闭原则(若添加车的类型，需修改代码)
    public static Car getCar(String car)
    {
        if ("五菱".equals(car)){return new WuLing();}
        else if ("特斯拉".equals(car)) {return new Model(); }
        else{return null;}
    }
    // 方法二
    public static Car getWuLing() { return new WuLing();}
    public static Car getModel(){return new Model();}
}
//输出
public class Consumer
{
    public static void main(String[] args)
    {
        // 正常方法
        WuLing wuLing = new WuLing();
        Model model = new Model();
        wuLing.name();model.name();
        // 使用工厂创建 方法一
        Car wuLingF = CarFactory.getCar("五菱");
        wuLingF.name();
        Car modelF = CarFactory.getCar("特斯拉");
        modelF.name();
        // 方法二
        Car wuLing2 = CarFactory.getWuLing();
        Car model2 = CarFactory.getModel();
        wuLing2.name(); model2.name();
    }
}
```



> ![image-20210801220202283](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801220202283.png)
>
> 优缺点：
>
> > - 优点是比较好理解，简单易操作。
> > - 缺点是违反了设计模式的 **ocp** **原则**，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修 改代码，或者尽可能少修改代码

### 6.4工厂方法模式



> 工厂方法模式：**定义了一个创建对象的抽象方法**，由子**类决定要实例化的类**。工厂方法模式将**对象的实例化推迟到子类**。

```java
//接口与接口的实现类与简单工厂模式定义相同
//创建工厂方法
// 工厂方法模式
public interface CarFactory
{
    Car getCar();
}
public class WuLingFactory implements CarFactory
{
    @Override
    public Car getCar()
    {
        return new WuLing();
    }
}
public class ModelFactory implements CarFactory
{
    @Override
    public Car getCar()
    {
        return new Model();
    }
}
输出

public class Consumer
{
    public static void main(String[] args)
    {
        Car car_WuLing = new WuLingFactory().getCar();
        Car car_Model = new ModelFactory().getCar();
        car_WuLing.name();
        car_Model.name();
        Car car_xiaoPeng = new XiaoPengFactory().getCar();
        car_xiaoPeng.name();
    }
}
```



[![image-20210801220051895](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801220051895.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210801220051895.png)

### 6.5抽象工厂模式



```java
//产品接口
// 手机接口
public interface PhoneProduct
{
    void start();
    void shutdown();
}
// 路由器产品接口
public interface RouterProduct
{
    void start();
    void shutdown();
}
//定义一个产品工厂
public interface IProductFactory
{
    // 生产手机
    PhoneProduct phoneProduct();
    // 生产路由器
    RouterProduct routerProduct();
}
//产品实现类
// 华为手机
public class HuaweiPhone implements PhoneProduct
{
    @Override
    public void start() {System.out.println("打开华为手机"); }
    @Override
    public void shutdown(){System.out.println("关闭华为手机");}
}
// 华为路由器
public class HuaweiRouter implements RouterProduct{
    @Override
    public void start(){System.out.println("打开华为路由器");}
    @Override
    public void shutdown(){ System.out.println("关闭华为路由器");}
}
// 小米手机
public class XiaomiPhone implements PhoneProduct{
    @Override
    public void start(){System.out.println("打开小米手机");}
    @Override
    public void shutdown(){System.out.println("关闭小米手机");}
}
// 小米路由器
public class XiaomiRouter implements RouterProduct{
    @Override
    public void start(){ System.out.println("打开小米路由器");}
    @Override
    public void shutdown(){System.out.println("关闭小米路由器");}
}
//创建产品工厂
public class HuaweiFactory implements IProductFactory{
    @Override
    public PhoneProduct phoneProduct() return new HuaweiPhone();}
    @Override
    public RouterProduct routerProduct(){return new HuaweiRouter();}
}
public class XiaomiFactory implements IProductFactory{
    @Override
    public PhoneProduct phoneProduct(){return new XiaomiPhone();}
    @Override
    public RouterProduct routerProduct(){return new XiaomiRouter();}
}
//输出
public class Client{
    public static void main(String[] args)
    {
        System.out.println("====================华为产品====================");
        PhoneProduct huaweiPhone = new HuaweiFactory().phoneProduct();
        huaweiPhone.start();
        huaweiPhone.callup();
        RouterProduct huaweiRouter = huaweiFactory.routerProduct();
        huaweiRouter.start();
        huaweiRouter.openWifi();
        System.out.println("====================小米产品====================");
        PhoneProduct xiaomiPhone = new XiaomiFactory().phoneProduct();
        xiaomiPhone.start();
        xiaomiPhone.callup();
        RouterProduct xiaomiRouter = xiaomiFactory.routerProduct();
        xiaomiRouter.start();
        xiaomiRouter.openWifi();
    }
}
```



> > ![image-20210801223200232](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210801223200232.png)
> >
> > 结论
>
> 抽象工厂模式
>
> - 定义: 抽象工厂模式提供了一个创建**一些列相关或者相互依赖对象的接口**，无需指定他们具体的类
> - 适用场景:
>   - 客户端(应用层) 不依赖与产品类实例如何被创建、实现等细节
>   - 强调一系列相关的产品对象(属于同一产品族) 一起使用创建对象需要大量的重复代码
>   - 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖具体的实现
> - 优点:
>   - 具体产品在应用层的代码隔离，无需关心创建的细节
>   - 将一个系列的产品统一到一起创建
> - 缺点:
>   - 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难;
>   - 增加了系统的抽象性和理难度

### 6.6结论



> 小结:
>
> - 简单工厂模式(静态工厂模式)
>   - 虽然某种成都上不符合设计原则，但**实际使用最多**
> - 工厂方法模式
>   - 不修改已有类的前提下，通过增加新的工厂类实现扩展
> - 抽象工厂模式
>   - 不可以增加产品，可以增加产品族

应用场景:

- JDK中**Calendar的getInstance方法**
- JDBC中的Connection对象的获取
- **Spring 中的IOC 容器创建管理bean对象**
- 反射中Class对象的newInstance方法

## 第 7 章 原型模式



### 7.1原型模式概念



> - 原型模式是指通过**复制一个已经存在的实例来返回新的实例，而不是新建实例**，被复制的实例就是我们所称的原型对象。调用者不需要知道任何创建细节，既然是拷贝实例获取新的实例，**因此不会直接调用构造方法**。
> - 核心组成
>   - **Prototype**: 声明克隆方法的接口，是所有具体原型类的公共父类，Cloneable接口
>   - **ConcretePrototype** : 具体原型类
>   - **Client**: 让一个原型对象克隆自身从而创建一个新的对象

### 7.2原型模式应用场景



> - 初始化消耗资源较多
>
> - 实例化一个对象需要繁琐的过程
>
> - 构造函数比较复杂
>
> - 循环体中产生大量对象时
>
> - **原型模式在 Spring 框架中源码分析**
>
> - > [![image-20210802094951406](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802094951406.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802094951406.png)

### 7.3**浅拷贝**



以拷贝文件为例

```
public class File implements Cloneable{
    private String name;
    private Date createTime;
    // 覆写clone方法
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
//测试
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        Date date = new Date();
        File file = new File("文件1",date);
        System.out.println(file);
        File copyFile = (File) file.clone();
        System.out.println(copyFile);
    }
}
```



> - **浅拷贝，**当我们Date对象改变时，两个file对象里的data也会发生相应的变化，因为这两个对象都指向同一个date对象.
>
> - > 1. 对于基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该**属性值复制**一份给新的对象。
>   > 2. 对于引用数据类型的成员变量，那么浅拷贝会进行 引用传递，也就是只是将该成员变量的**引用值（内存地址）复制一份给新的对象**。因为实际上两个对象的该成 员变量都**指向同一个实例**。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值

### 7.4**深拷贝**



### 7.4.1修改clone方法



```java
@Override
protected Object clone() throws CloneNotSupportedException {
    Object file = super.clone();
((File)file).createTime = (Date) this.getCreateTime().clone();//将Date对象进行copy
    return file;
}
--------
     @Override
    protected Object clone() throws CloneNotSupportedException {
        Student cloneStudent= (Student) super.clone();
        cloneStudent.setAddress((Address) this.address.clone());   设置对象属性为clone
        return cloneStudent;
    }
```



### 7.4.2实现序列化接口



```java
class File implement Serializable {
	public File deepClone() {
    try {
        // 输出 (序列化)
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(this);
        // 输入 (反序列化)
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        Person person = (Person) ois.readObject();
        return person;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
}
----------------------
```



> **深拷贝**，当我们Date对象改变时，原型file对象里的data会发生相应的变化，克隆对象里的data不会发生变化，因为这两个对象分别指向不同date对象.

## 第 8 章 建造者模式



### 8.1概述



> - **定义：将一个复杂对象的构建与表示分离**
> - **作用：在用户不知道 对象的建造过程和细节的情况下可以直接创建复杂对象**

### 8.2角色



> - Builder
>   - **抽象建造者: 为创建一个产品指定构造部件的方法,由具体建造者去实现**
>   - **具体实现来依赖Builder接口 面向接口编程**
>   - 例子：建房子的图纸，这张图纸有建房子的步骤(打地基，打钢筋，装修),无论是建高楼还是别墅你都要来实现这个Builder
> - ConcreteBuilder
>   - **具体建造者: 实现抽象建造者的方法，构造或装配对象**
>   - **Builder的实现类,创建复杂对象的细节在实现方法中**
>   - 例子：建高楼(具体建造者)根据图纸(抽象建造者)给出的步骤去实现详细过程
> - Product
>   - **产品: 表示被建造的复杂对象，内部由ConcreteBuild去实现,最终由Director生产出来**
>   - **最终被创建出来的产品**
>   - 例子：房子被创建出来了
> - Director
>   - **指挥者: 调用ConcreteBuilder实现的建造方法,生产出Product产品**
>   - **接收Builder的实现类ConcreteBuilder,调用创建对象详细方法,返回产品**
>   - 例子: 指挥创建房子

```
//产品： 房子  由具体建造者来创建产品的内部
public class Product {
    private String buildA;
    private String buildB;
    private String buildC;
    @Override
    public String toString() {
        return "Product{" +
                "buildA='" + buildA + '\'' +
                ", buildB='" + buildB + '\'' +
                ", buildC='" + buildC + '\'' +
                '}';
    }
    // 字段的get/set方法...
}
----------------------------------------------------------------------
//抽象建造者：像图纸一样 规定好造房子步骤,让具体建造者去依赖 (面向接口编程)
public abstract class Builder {
    abstract void buildA();//打地基
    abstract void buildB();//打钢筋
    abstract void buildC();//装修
    abstract Product getProduct();
}
-------------------------------------------------------------------------
   //具体建造者 : 工人 按照图纸（建造者）要求 打造 产品（房子）
public class ConcreteBuilder extends Builder {
    private Product product;
    public ConcreteBuilder() { this.product = new Product();}
    @Override
    void buildA() {product.setBuildA("打地基");}
    @Override
    void buildB() {product.setBuildB("打钢筋");}
    @Override
    void buildC() {product.setBuildC("装修");}
    @Override
    Product getProduct() { return product;}
} 
----------------------------------------------------------------------
//指挥并构造一个使用Builder的对象  核心 负责指挥一个房子如何去建造
public class Director {
    //指挥建造房子 
    public Product build(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        return builder.getProduct();
    }
}
------------------------------------------------------------------------
    //客户端
public class Client {
    public static void main(String[] args) {
        //指挥 建造房子 最终得到这个房子
        //表示层
        Director director = new Director();
        Product product = director.build(new ConcreteBuilder());
        /*
        曾经创建层表示层未分离:
        Product p = new Product();p.setBuildA();
        p.setBuildB(); p.setBuildC();
        */
        System.out.println(product.toString());
    }
}
```



> - **将复杂对象的创建层与表示层分离**
> - [![image-20210802111216424](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802111216424.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802111216424.png)
> - 建造者模式结合**链式编程**来使用，代码上更加美观

### 8.3建造者模式与抽象工厂模式的比较:



> - 建造者模式返回一个组装好的完整产品 ， 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族
>
> - **建造者模式**是把对象的创建分散开来，**每个抽象方法负责其中的一部分**。**抽象工厂**是每个方法负责一个**产品族**。
>
> - **建造者模式所有函数加到一起才能生成一个对象。抽象工厂一个函数生成一个对象**。
>
> - > - 比如华为手机制造，华为荣耀系列 和 华为Nova系列的产品生产,**抽象工厂**有两个子厂分别负责实际生产荣耀系列手机(荣耀产品族) 和 华为Nova系列手机(Nova产品族)
>   > - 两个子工厂的生产流水线上拼凑组装华为手机产品的过程叫做**建造者模式**

### 8.4建造者模式在 JDK 的应用和源码分析



[![image-20210802113103682](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802113103682.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802113103682.png)

> - 源码中建造者模式角色分析
>
> - > - Appendable 接口定义了多个 append 方法(抽象方法), 即 Appendable 为**抽象建造者**, 定义了抽象方法
>   > - AbstractStringBuilder 实现了 Appendable 接口方法，这里AbstractStringBuilder 已经是**建造者**，只是不能实例化
>   > - StringBuilder 即充当了**指挥者角色**，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而 StringBuilder 继承了 AbstractStringBuilder

## 第 9 章 适配器设计模式



### 9.1 基本介绍



> - 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，**主的目的是兼容性**，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)
> - 适配器模式属于**结构型模式**
> - 主要分为三类：**类适配器模式、对象适配器模式、接口适配器模**式

### 9.2 工作原理



> 1. 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容
> 2. 从用户的角度看不到被适配者，是解耦的
> 3. **用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法**
> 4. 用户收到反馈结果，感觉只是和目标接口交互，如图
>
> ![image-20210802154533413](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802154533413.png)

### 9.3 类适配器模式



#### 9.3.1类适配器模式介绍



基本介绍：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src->dst 的适配。

#### 9.3.2类适配器模式应用实例



> - 应用实例说明
>
> - > 以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电
>
> - 思路分析(类图)
>
> - > [![image-20210802154907513](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802154907513.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802154907513.png)

```
public class Client {
    public static void main(String[] args) {
        System.out.println(" === 类适配器模式 ====");
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter());
    }
}
public class Phone {
    //充电
    public void charging(IVoltage5V iVoltage5V) {
        if (iVoltage5V.output5V() == 5) {
            System.out.println("电压为 5V, 可以充电~~");
        } else if (iVoltage5V.output5V() > 5) {
            System.out.println("电压大于 5V, 不能充电~~");
        }
    }
}
public interface IVoltage5V {
    public int output5V();
}
public class Voltage220V {
   // 输出 220V 的电压
    public int output220V() {
        int src = 220;
        System.out.println("电压=" + src + "伏");
        return src;
    }
}
public class VoltageAdapter extends Voltage220V implements IVoltage5V {
    @Override
    public int output5V() {
        //获取到 220 V 电压 
        int srcV = output220V();
        int dstV = srcV / 44;
        return dstV;
    }
}
```



#### 9.3.3类适配器模式注意事项和细节



> - Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局 限性;
> - src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。
> - 由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。

### 9.4 对象适配器模式



#### 9.4.1对象适配器模式介绍



> - 基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src->dst 的适配
> - 根据“**合成复用原则**”，在系统中尽量使用**关联关系（组合）来替代继承**关系。
> - 对象适配器模式是适配器模式常用的一种

```
public class Client {
    public static void main(String[] args) {
        System.out.println(" === 对象适配器模式 ====");
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter(new Voltage220V()));
    }
}
//适配器类
public class VoltageAdapter implements IVoltage5V {
    private Voltage220V voltage220V;
    //关联关系-聚合通过构造器，传入一个 Voltage220V实例
    public VoltageAdapter(Voltage220V voltage220v)  {this.voltage220V = voltage220v;}
    @Override
    public int output5V() {
        int dst = 0;
        if (null != voltage220V) {
            int src = voltage220V.output220V();
            System.out.println("使用对象适配器，进行适配~~");
            dst = src / 44;
            System.out.println("适配完成，输出的电压为=" + dst);
        } return dst;
    }
}
```



#### 9.4.3对象适配器模式注意事项和细节



> - 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，**使用组合替代继承**， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst 必须是接口。
> - 使用成本更低，更灵活。

### 9.5 接口适配器模式



#### 9.5.1接口适配器模式介绍



> - 一些书籍称为：适配器模式(Default Adapter Pattern)或**缺省适配器模式**。
> - 核心思路：当**不需要全部实现接口提供的方法**时，可先**设计一个抽象类**实现**接口**，并为该接口中每个方法提供 一个**默认实现（空方法）**，那么该**抽象类的子类可有选择地覆盖父类的某些方法**来实现需求
> - 适用于一个**不想接口使用所有的方法**的情况。

#### 9.5.2接口适配器模式应用实例



```
public interface Interface4 { 
public void m1(); 
public void m2();}

//在 AbsAdapter 我们将 Interface4 的方法进行默认实现 
public abstract class AbsAdapter implements Interface4 { 
//默认实现 
public void m1() { }
public void m2() { } }

public class Client { public static void main(String[] args) {
    AbsAdapter absAdapter = new AbsAdapter() { 
        //只需要去覆盖我们 需要使用 接口方法 
        @Override public void m1() { 
            System.out.println("使用了 m1 的方法"); } }; 
    absAdapter.m1(); } }
```



### 9.6适配器模式在 SpringMVC 框架应用的源码剖析



> - SpringMvc 中的 **HandlerAdapter,** 就使用了适配器模式
>
> - SpringMVC 处理请求的流程回顾
>
> - 使用 HandlerAdapter 的原因分析:
>
> - > 可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 OCP 原则。
>   >
>   > [![image-20210802161029943](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802161029943.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802161029943.png)[![image-20210802163604852](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802163604852.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802163604852.png)

[![image-20210802160845079](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802160845079.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802160845079.png)

### 9.7 适配器模式的注意事项和细节



> - 三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。
> - 类适配器：以类给到，在 Adapter 里，就是将 src 当做类，**继承**
> - 对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，**持有**
> - 接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，**实现**
> - Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。

## 第 10 章桥接模式



### 10.1概述



> - **定义**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
>
> - **意图**：将抽象与实现解耦。
>
> - > 桥接模式主要应对的是由于实际的需要，**某个类具有两个或者两个以上的维度变化（违反了SRP单一原则）**，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿。
>   >
>   > 如果每个对应的类型品牌都编写对应的类，就会造成代码的冗余
>   >
>   > [![image-20210802173718766](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802173718766.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802173718766.png)[![image-20210802173744343](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802173744343.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802173744343.png)

### 10.2代码实例



```
//品牌接口
public interface Brand {
    void info();
}
//各品牌实现类
public class Lenovo implements Brand{
    public void info() {System.out.println("联想品牌..");}
}
public class Apple implements Brand{
    public void info() {System.out.println("苹果品牌..");}
}
//电脑类型，是抽象的数据类型，它并没有做一些具体的事情，
// 这里不要定义为接口，因为电脑的品牌是属性，使用组合来实现，电脑出厂是自带品牌的
public class Computer {
    // 这里使用protected，这样子类继承的时候就可以直接使用了
    protected Brand brand;
    public Computer(Brand brand){
        this.brand = brand;
    }
    public void info(){
        brand.info();
    }
}
//类型
public class Desktop extends Computer{
    public Desktop(Brand brand) {
        super(brand);
    }
    public void info() {
        super.info();
        System.out.println("台式机..");
    }
}
public class Laptop extends Computer{
    public Laptop(Brand brand) {
        super(brand);
    }
    public void info() {
        super.info();
        System.out.println("笔记本..");
    }
}
//测试
public class Client {
    public static void main(String[] args) {
        Desktop desktop = new Desktop(new Lenovo());
        desktop.info();
        Laptop laptop = new Laptop(new Dell());
        laptop.info();
    }
}
```



[![image-20210802174214903](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802174214903.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802174214903.png)

> 我们在电脑里直接将品牌组合进来，这样电脑就自带品牌了，通过组合的方式搭建了一座桥，所以我们如果要增加一个类型，例如超级计算机，只要继承computer，这个计算机就自带品牌属性了，而品牌是从brand拿过来的，新增一个品牌也不会影响类型的操作，两者互不影响，可以随意扩展

### 10.3优缺点以及实际应用场合



> **优势**
>
> - 桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多，桥接模式是比多继承方案更好的解决方法。极大的减少了子类的个数，从而降低管理和维护的成本
> - 桥接模式**提高了系统的可扩充性**，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。符合开闭原则，就像一座桥，可以把两个变化的维度连接起来!
>
> **劣势**
>
> - 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
> - 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。
>
> **最佳实际**
>
> - 如果一个系统需要在构建的**抽象化角色和具体化角色之间增加更多的灵活性**，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在**抽象层建立一个关联关系**。抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
>
> - **一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。**
>
> - 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。
>
>   **场景**
>
>   - Java语言通过Java虚拟机实现了平台的无关性。
>
>   - AWT中的Peer架构
>
>   - **JDBC**驱动程序也是桥接模式的应用之一。
>
>   - > [![image-20210802180541641](https://github.com/Flavor20640513/code/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/resources/image-20210802180541641.png)](https://github.com/Flavor20640513/code/blob/master/设计模式/resources/image-20210802180541641.png)
